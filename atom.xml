<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rong</title>
  
  <subtitle>前端学习者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pan-rong.github.io/"/>
  <updated>2018-03-05T10:06:37.589Z</updated>
  <id>https://pan-rong.github.io/</id>
  
  <author>
    <name>Rong Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6学习笔记</title>
    <link href="https://pan-rong.github.io/2018/03/03/ES6notes/"/>
    <id>https://pan-rong.github.io/2018/03/03/ES6notes/</id>
    <published>2018-03-03T06:30:02.000Z</published>
    <updated>2018-03-05T10:06:37.589Z</updated>
    
    <content type="html"><![CDATA[<p>ES6简介<br>ES6是ES5的升级，它们都是JS编程语言现今的最大更新。95年出现了JS语言。<br><a id="more"></a><br>以下从4个方面讲解ES6新增：1.语法 2.函数 3.内置功能 4.开发者工具<br>    1.语法：新增(1) 变量let和const;(2) 模板字面量;(3) 解构;(4) 对象字面量简写法;(5) 迭代;(6) 展开…运算符;(7) 剩余参数;<br>    2.函数：新增(1) 箭头函数;(2) 函数里新增默认函数参数;(3) JS中的类(和ES5有区别)<br>    3.内置功能：新增(1) Symbol(标识符);(2) Set(集合);(3) WeakSet(弱集合);(4) Map(映射);(5) WeakMap(弱映射);<br>                   (6) Promise(异步); (7) Proxy(代理);(8) 生成器(generator);<br>    4.开发者工具:(1) Polyfill;(2) Babel(JS转译器)</p><h2 id="1-语言上的新增"><a href="#1-语言上的新增" class="headerlink" title="1.语言上的新增"></a>1.语言上的新增</h2><p><strong>(1) 变量let和const</strong></p><pre><code>两种新的方式来声明变量：let和const；它们的作用域是到块(即用花括号表示)，而不是函数，不会提升；而var会提升到全局作用域或本地作用域即整个函数作用域。在代码块中使用let和const声明变量，该变量会陷入暂时性死区，直到该变量的声明被处理；这种行为会阻止变量被访问，除非它们被声明了。</code></pre><p>let和const的规则</p><pre><code>使用let声明的变量可以重新赋值，但是不能在同一作用域内重新声明使用const声明的变量必须赋初始值，但是不能在同一作用域内重新声明，也无法重新赋值。</code></pre><p><strong>(2) 模板字面量</strong></p><pre><code>ES6引入了模板字面量(在ES6开发版本中叫“模板字符串”)，其本质上是包含嵌入式表达式的字符串字面量。模板字面量是用倒引号(``)表示，可以包含用${expression}表示的占位符，且将换行符当成字符串的一部分。模板字面量中的嵌入式表达式不仅仅可以用来引用变量。你可以在嵌入式表达式中进行运算、调用函数和使用循环。</code></pre><p><strong>(3) 解构</strong></p><pre><code>在ES6中，可以使用解构从数组和对象中提取值并赋给独特的变量。解构：从Perl和Python等语言中获得灵感，使你能够指定要从赋值左侧上的数组或对象中提取的元素。例1 解构数组：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const point = [10, 25, -34];</span><br><span class="line">const [x, y, z] = point;</span><br><span class="line">console.log(x, y, z);</span><br><span class="line">Prints: 10 25 -34</span><br></pre></td></tr></table></figure><pre><code>上述中，方括号 [ ] 表示被解构的数组，x、y 和 z 表示要将数组中的值存储在其中的变量。注意，你不需要指定要从中提取值的索引，因为索引可以暗示出来。例2 解构对象</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const gemstone = &#123;</span><br><span class="line">type: &apos;quartz&apos;,</span><br><span class="line">color: &apos;rose&apos;,</span><br><span class="line">karat: 21.29</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;type, color, karat&#125; = gemstone;</span><br><span class="line">console.log(type, color, karat);</span><br><span class="line">Prints: quartz rose 21.29</span><br></pre></td></tr></table></figure><pre><code>上述中，花括号 { } 表示被解构的对象，type、color 和 karat 表示要将对象中的属性存储到其中的变量。因为 gemstone具有 type 属性，值自动存储在 type 变量中。</code></pre><p> <strong>(4) 对象字面量简写法</strong></p><pre><code>在删掉不必要重复代码中，ES6推出了新简写法，例：对象字面量简写法：用来初始化对象并向对象中添加方法，使用和所分配的变量名称相同的名称初始化对象，可重对象属性中删除该属性。对象中简写方法名称：对象中添加方法时，可以省掉function关键字</code></pre><p> <strong>(5) 迭代</strong></p><pre><code>1.ES6中添加了一个新的可迭代接口，它允许我们自定义对象的迭代方式(即循环遍历方式)，2.ES6中新增了一个循环，即for...of..,专门遍历可迭代对象(即实现了这个新迭代接口的对象，如string，array，Map和Set)for...of循环(优势)循环访问任何可迭代的数据类型，和for...in相似，但可以忽略索引(代码最简)；且可随时停止或退出for...of循环；不用担心向对象中添加新属性，for...of循环只循环访问对象中的值。</code></pre><p><strong>(6) 展开…运算符</strong></p><pre><code>ES6中新增了展开运算符(用三个连续的点...表示)，可将字面量对象展开为多个元素例1 展开集合：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);</span><br><span class="line">console.log(...primes);</span><br><span class="line">Prints: 2 3 5 7 11 13 17 19 23 29</span><br></pre></td></tr></table></figure><pre><code>例2 结合数组：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;pears&quot;];</span><br><span class="line">const vegetables = [&quot;corn&quot;, &quot;potatoes&quot;, &quot;carrots&quot;];</span><br><span class="line">//const produce = fruits.concat(vegetables);</span><br><span class="line">const produce = [...fruits,...vegetables];</span><br><span class="line">console.log(produce);</span><br><span class="line">Prints: [&quot;apples&quot;, &quot;bananas&quot;, &quot;pears&quot;, &quot;corn&quot;, &quot;potatoes&quot;, &quot;carrots&quot;]</span><br></pre></td></tr></table></figure><p><strong>(7) 剩余参数</strong></p><pre><code>ES6中新增的另一个运算符，剩余参数也用三个连续点...表示，使你能够将不定数量的元素表示为数组。例1、将变量赋数组值时：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const order = [20.17, 18.67, 1.50, &quot;cheese&quot;, &quot;eggs&quot;, &quot;milk&quot;, &quot;bread&quot;];</span><br><span class="line">const [total, subtotal, tax, ...items] = order;</span><br><span class="line">console.log(total, subtotal, tax, items);</span><br><span class="line">Prints: 20.17 18.67 1.5 [&quot;cheese&quot;, &quot;eggs&quot;, &quot;milk&quot;, &quot;bread&quot;]</span><br></pre></td></tr></table></figure><pre><code>例2、可变参数函数(即接受不定数量参数的函数)在此之前可使用参数对象(arguments),现在可以使用剩余参数：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(...nums) &#123;</span><br><span class="line">  let total = 0;  </span><br><span class="line">  for(const num of nums) &#123;</span><br><span class="line">    total += num;</span><br><span class="line">  &#125;</span><br><span class="line">  return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数新增"><a href="#2-函数新增" class="headerlink" title="2.函数新增"></a>2.函数新增</h2><p><strong>(1) 箭头函数(箭头函数表达式)</strong></p><pre><code>ES6新增函数，箭头函数，例,转换数组中的大小写：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const upperizedNames = [&apos;Farrin&apos;, &apos;Kagure&apos;, &apos;Asser&apos;].map(</span><br><span class="line">    name =&gt; name.toUpperCase()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><pre><code>将“普通”函数转换成箭头函数的步骤：1.删掉关键字 function2.删掉圆括号3.删掉左右花括号4.删掉关键字 return5.删掉分号6.在参数列表和函数主体之间添加一个箭头（=&gt;）</code></pre><p>箭头函数和普通函数的区别：</p><pre><code>普通函数可以是函数声明或函数表达式，但箭头函数始终是表达式；所以仅在表达式有效时才能使用箭头函数，如：1.存储在变量中2.当做参数传递给函数3.存储在对象的属性中参数列表出现在箭头函数的箭头(=&gt;)前面，当只有一个参数时，可以直接写参数名；若有多个或零个，则需要用圆括号。当箭头函数的函数主体只有一个表达式时，在函数主体周围没有花括号；自动返回表达式当函数主体需多行代码时，需将函数主体放在花括号内，需要使用return语句来返回内容</code></pre><p>“this”在普通函数和箭头函数中的使用</p><pre><code>在普通函数中，this取决于它的函数(或方法)是如何被调用的，例：1.新的对象(使用new调用)，则构造函数中的this的值是新的对象2.指定的对象(使用call或apply调用)  注：call和apply的区别，call方法接受的是若干个参数的列表；而apply方法接受的是一个      包含多个参数的数组。3.上下文对象(即点符号左边的对象)4.全局对象或undefined  以上三种情况都不存在是，函数中的this的值是全局对象，在严格模式下是undefined在箭头函数中的this:箭头函数中，this的值基于函数周围的上下文，即this的值与函数外面的this的值一样</code></pre><p> <strong>(2) 默认函数参数</strong>   </p><pre><code>ES6中新的方式创建默认值，即默认函数参数；要创建默认参数，需要添加等号(=)以及当参数未提供时参数应该设为默认值，其可以为任何JS数据类型当默认函数参数和解构一起使用时，战斗力提升好几倍~例：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createGrid([width = 5, height = 5] = []) &#123;</span><br><span class="line">  return `Generating a grid of $&#123;width&#125; by $&#123;height&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">createGrid(); // Generates a 5 x 5 grid</span><br><span class="line">Returns: Generates a 5 x 5 grid</span><br></pre></td></tr></table></figure><p><strong>(3) JS中的类</strong></p><pre><code>JS不是基于类的语言，它使用函数来创建对象，并通过原型将它们关联在一起。所谓的JS类本质上还是一样的。ES5中的类1.构造函数使用new关键字被调用2.按照惯例，构造函数名以大写字母开头3.构造函数控制将被创建的对象的数据的设置4.“继承”的方法被放在构造函数的原型对象上ES6中类,新类的编写：(注：类里各函数之间不要逗号)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Plane &#123;</span><br><span class="line">  constructor(numEngines) &#123;</span><br><span class="line">    this.numEngines = numEngines;</span><br><span class="line">    this.enginesActive = false;</span><br><span class="line">   &#125;</span><br><span class="line">    startEngines() &#123;</span><br><span class="line">      console.log(&apos;starting engines…&apos;);</span><br><span class="line">      this.enginesActive = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//以下是ES5中的startEngines定义,且ES5中类定义没有构造器函数，像普通函数一样定义</span><br><span class="line">//Plane.prototype.startEngines = function () &#123;</span><br><span class="line">//  console.log(&apos;starting engines...&apos;);</span><br><span class="line">//  this.enginesActive = true;</span><br><span class="line">//&#125;;</span><br></pre></td></tr></table></figure><pre><code>ES6中的子类在ES6中，使用super和extends关键字扩展类；关键字extends将自己设为子类，要让子类可以访问到父类，需要使用关键字super。super既可被用作函数，也可被用作对象，但是super必须在this之前被调用，例：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Tree &#123;</span><br><span class="line">    constructor(size = &apos;10&apos;, leaves = &#123;spring: &apos;green&apos;, summer: &apos;green&apos;, fall: &apos;orange&apos;, winter: null&#125;) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.leaves = leaves;</span><br><span class="line">        this.leafColor = null;</span><br><span class="line">    &#125;   </span><br><span class="line">    changeSeason(season) &#123;</span><br><span class="line">        this.leafColor = this.leaves[season];</span><br><span class="line">        if (season === &apos;spring&apos;) &#123;</span><br><span class="line">        this.size += 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Maple extends Tree &#123;</span><br><span class="line">    constructor(syrupQty = 15, size, leaves) &#123;</span><br><span class="line">        super(size, leaves);</span><br><span class="line">        this.syrupQty = syrupQty;</span><br><span class="line">    &#125;</span><br><span class="line">    changeSeason(season) &#123;</span><br><span class="line">        super.changeSeason(season);</span><br><span class="line">        if (season === &apos;spring&apos;) &#123;</span><br><span class="line">            this.syrupQty += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    gatherSyrup() &#123;</span><br><span class="line">        this.syrupQty -= 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ES6新增内置功能"><a href="#3-ES6新增内置功能" class="headerlink" title="3.ES6新增内置功能"></a>3.ES6新增内置功能</h2><p><strong>(1) Symbol(标识符)</strong>   </p><pre><code>Symbol 只是一个唯一标识符，最常用于唯一标识对象中的属性(如对象中属性的名字相同但value不同时).但是不能用来访问标识符本身。Symbol的创建：Symbol(),并添加一个可选的字符串作为其描述。例：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&apos;apple&apos;);</span><br><span class="line">console.log(sym1);//Symbol(apple)</span><br></pre></td></tr></table></figure><p><strong>(2) 迭代器协议和可迭代协议(不是ES6内置)</strong></p><pre><code>ES6中新增的两个协议：迭代器协议和可迭代协议其中，可迭代协议用来定义和自定义对象的迭代行为；工作原理：为了使对象可迭代，它必须实现可迭代接口(即必须包含默认的迭代器方法)。迭代器协议用来定义对象生成一系列值的标准方式；即定义对象如何迭代的流程。工作原理：通过执行.next() 方法来完成这一流程。next()方法是无参数函数，返回具有两个属性的对象：value(下个值数据)和done(为false继续迭代，为true达到末尾);</code></pre><p><strong>(3) Set(集合、单值、ES6内置可迭代)</strong></p><pre><code>Set()数学意义上的集合，即每个数字都是唯一的，只出现一次；不基于索引，不可单独被访问.Set创建：new  Set();Set修改：.add()增加，.delete()删除，.clear()清除注：若增加时，条目重复，则Set中不增加(返回Set对象)；若删除时，条目没有，则不删除(成功返回true,失败返回false)Set使用：  .size返回条目数；  .has()检查Set中是否存在某个条目，若有返回true，没有返回false  .values()返回Set中的SetIterator对象，即所有值；  .keys()同.values()Set循环访问：  1.使用SetIterator和.next()访问Set中的每一项</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const iterator = months.values();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure><pre><code>2.使用for...of循环</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const colors = new Set([&apos;red&apos;, &apos;orange&apos;, &apos;yellow&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;violet&apos;, &apos;brown&apos;, &apos;black&apos;]);</span><br><span class="line">for (const color of colors) &#123;</span><br><span class="line">     console.log(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) WeakSet(弱集合)</strong>    </p><pre><code>WeakSet和Set的区别：  1.WeakSet只能包含对象；  2.WeakSet无法迭代，不能循环访问  3.WeakSet没有.clear()方法WeakSet创建：new WeakSet();垃圾回收：JS中创建新值会分配内存，当这些值不需要时，将自动释放内存。该过程就称为垃圾回收WeakSet 通过专门使用对象作为键值来利用这一点。如果将对象设为 null，则本质上是删除该对象，当 JS 的垃圾回收器运行时，该对象之前占用的内存将被释放，以便稍后在程序中使用。</code></pre><p><strong>(5) Map(映射)</strong></p><pre><code>Map是一个可以存储键值对的对象，键和值都可以是对象、原始值或二者的结合。Map创建：new Map();与Set不同，其不能通过值列表创建，要使用.set()方法添加键值。Map处理：    .set()方法，有两个参数，第一个参数是键，用来引用第二个参数即值；    .delete()方法移除键值对；    .clear()清除所有键值对  注：.set()方法添加已存在的，不会报错，但会覆盖；.delete()方法删除不存在的，不变；成功为true，失败为false    .has()传入键来检查Map中是否存在该键值对    .get()方法传入键，检查Map中的值    .keys()&amp;.values()将返回新的迭代器对象MapIteratorMap循环访问：  1.使用MapIterator和.next()循环访问每个键或值(取决于使用keys或values)  2.使用for...of循环访问键值对  3.使用Map的.forEach()访问  </code></pre><p><strong>(6) WeakMap(弱映射)</strong>    </p><pre><code>WeakMap和Map的关键区别：  1.WeakMap只能包含对象作为键，  2.WeakMap无法迭代  3.WeakMap没有.clear()方法WeakMap创建：new WeakMap()垃圾回收：(同WeakSet)</code></pre><p><strong>(7) Promise</strong>   </p><pre><code>promise 使你能够展开一些可以异步完成的工作，并回到常规工作Promise的创建：    new Promise()；创建 promise 时，必须向其提供异步运行的代码(即带初始函数);Promise通过向初始函数中传入两个函数来提示请求成功或失败，通常我们将这两个函数称为resolve(成功)和reject(失败)Promise立即返回对象Promise将立即返回一个对象，该对象具有一个.then()方法，我们可以让该方法通知我们promise中的请求成功与否。.then()方法会接收两个函数：  1.请求成功完成时要运行的函数  2.请求失败时要运行的函数</code></pre><p><strong>(8) Proxy</strong>         </p><pre><code>让一个对象代表另一个对象，来处理另一个对象的所有交互。代理可以直接处理请求，接收或发送目标对象数据等。Proxy的创建：  new Proxy()；Proxy构造函数接收两个项目：    1.它将要代理的对象    2.包含将为被代理对象处理的方法列表的对象(即处理器handler)    例：</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">var agent = new Proxy(richard, &#123;&#125;);</span><br><span class="line">agent.status; // returns &apos;looking for work&apos;</span><br></pre></td></tr></table></figure><pre><code>handler对象中的Get Trap(捕获器)和Set Trap;trap是一种函数，如果未定义trap,默认行为会被发送给目标对象1. Get Trap(捕获器)    get 用来截获对属性的调用,它不会实际地输出属性！</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">          const richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">          const handler = &#123;</span><br><span class="line">                get(target, propName) &#123;</span><br><span class="line">                    console.log(target); // the `richard` object, not `handler` and not `agent`</span><br><span class="line">                    console.log(propName); // the name of the property the proxy (`agent` in this case) is </span><br><span class="line">                                           //checking</span><br><span class="line">                    return target[propName];//可在调用后输出返回的值</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">            const agent = new Proxy(richard, handler);</span><br><span class="line">            agent.status; // logs out the richard object (not the agent object!) and the name of the property </span><br><span class="line">                          // being accessed (`status`)</span><br><span class="line">```   </span><br><span class="line">    2. set trap    </span><br><span class="line">          </span><br><span class="line">        set trap 用来截获将更改属性的代码</span><br></pre></td></tr></table></figure><pre><code>const richard = {status: &apos;looking for work&apos;};const handler = {    set(target, propName, value) {        if (propName === &apos;payRate&apos;) { // if the pay is being set, take 15% as commission              value = value * 0.85;            }          target[propName] = value;      }  };  const agent = new Proxy(richard, handler);  agent.payRate = 1000; // set the actor&apos;s pay to $1,000  agent.payRate;// $850 the actor&apos;s actual pay</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    3. Proxy中有13种不同的捕获器 </span><br><span class="line">        </span><br><span class="line">    4. 和ES5种额Getter/Setter相比，</span><br><span class="line">        Proxy种的get/set在初始化对象时，不需要针对每个属性使用 getter/setter 初始化对象.</span><br><span class="line"></span><br><span class="line">**(9) 生成器(generator)**</span><br><span class="line">          </span><br><span class="line">    生成器(generator)，可在暂停的函数。</span><br><span class="line"></span><br><span class="line">    定义方法：在function后面加上*星号；</span><br><span class="line"></span><br><span class="line">    调用：生成器被调用时，不会运行函数中的任何代码，而是创建和返回迭代器。该迭代器可以用来运行实际生成器的内部代码。</span><br><span class="line">        调用.next()函数。</span><br><span class="line"></span><br><span class="line">    在生成器中，出现了关键字yield。yield会导致生成器暂停下来；</span><br><span class="line">    yield关键字放在要暂停的语句后面，并且迭代器会记住上次暂停的位置；</span><br><span class="line">    若想用yield向外界生成数据，yield+数据；则每次暂停后会返回该数据</span><br><span class="line"></span><br><span class="line">    将数据发送回生成器中，使用.next()方法；例：</span><br></pre></td></tr></table></figure><pre><code>function* displayResponse() {    const response = yield;//    console.log(`Your response is &quot;${response}&quot;!`); }const iterator = displayResponse();iterator.next(); // starts running the generator functioniterator.next(&apos;Hello Udacity Student&apos;); // send data into the generator// the line above logs to the console: Your response is &quot;Hello Udacity Student&quot;!</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## 4.专业开发者功能</span><br><span class="line"></span><br><span class="line">主流浏览器的平台功能更新网址：</span><br><span class="line"></span><br><span class="line">[Google Chrome]( https://www.chromestatus.com/features#ES6)</span><br><span class="line"></span><br><span class="line">[Microsoft Edge](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/?q=ES6)</span><br><span class="line"></span><br><span class="line">[Mozilla Firefox](https://platform-status.mozilla.org/)</span><br><span class="line"></span><br><span class="line">[Safari( Webkit)](https://webkit.org/status/)</span><br><span class="line"></span><br><span class="line">[EMCAScript兼容性表格](http://kangax.github.io/compat-table/es6/)</span><br><span class="line"></span><br><span class="line">**[Polyfill](https://en.wikipedia.org/wiki/Polyfill)**[polyfill的HTML5样板文件团队](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)</span><br><span class="line"></span><br><span class="line">    Polyfill是通过复制某些浏览器没有的原生功能，来修复这些缺失的JS文件；</span><br><span class="line">    Ployfill(或polyfiller)是一段代码(或插件)，可提供本希望浏览器能原生提供的技术</span><br><span class="line">    例：</span><br></pre></td></tr></table></figure><pre><code>if (!String.prototype.startsWith) {//避免覆盖原生startsWith方法    String.prototype.startsWith = function (searchString, position) {        position = position || 0;        return this.substr(position, searchString.length) === searchString;    };  }</code></pre><p><code>`</code></p><p><strong><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel(JS转译器)</a></strong></p><pre><code>Babel可以将ES6转换成ES5，也可以将JSX(JS扩展语言)转化成JS，并将 Flow 转换为JS.</code></pre>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="ES6" scheme="https://pan-rong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="https://pan-rong.github.io/2018/03/01/CSSnotes/"/>
    <id>https://pan-rong.github.io/2018/03/01/CSSnotes/</id>
    <published>2018-03-01T02:34:36.000Z</published>
    <updated>2018-03-05T09:50:42.300Z</updated>
    
    <content type="html"><![CDATA[<p>CSS简介<br><a id="more"></a><br><strong>1、CSS选择器</strong><br>CSS选择器即通过某种规则来匹配相应的标签，并为其设置CSS样式，常用的有类选择器、标签选择器、ID选择器、后代选择器、群组选择器伪类选择器(before/after)、兄弟选择器(+~)、属性选择器等等。</p><p><strong>2、CSS Reset</strong><br>HTML在不设置任何样式的情况下，也会有一个默认的CSS样式，这是因为浏览器自带的。而不同的浏览器对于这个默认样式的CSS设置也不同，这就会导致代码兼容的问题。为了保证代码的兼容性，通常需要在初始化时，将其统一；用通标符(<em>)可以实现,这就是CSS样式的Reset。例：</em>{margin:0;padding:0}</p><p><strong>3、盒子布局</strong><br>盒子模型是CSS布局的基石。常见的盒子模型有块级盒子(block)和行内盒子(inline-block),与盒子相关的几个属性：margin、border、padding和content等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing属性的设置会影响盒子的width和height的计算.</p><p><strong>4、浮动布局</strong><br>设置元素的float属性值为left或right，就能使该元素脱离普通文档流，向左或向右浮动。一般在宫格布局时会用到，如果子元素全部设置位浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素的末尾加空元素设置clear:both;更高级一点的就给父容器设置before/after来模拟一个空元素，还可以直接设置overflow属性为auto/hidden来清除浮动。初浮动可以实现宫格布局，行内盒子(inline-block)和table也可以实现同样的效果.</p><p><strong>5、定位布局</strong><br>设置元素的position属性值为relative/absolute/fixed,就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，<br>relative是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用；<br>absolute是绝对定位，它以离自己最近的定位父容器作为参照进行偏移；为了对某个元素进行定位，常用的方式就是设置父容器的position:relative,因为相对定位元素在不设置top和left值时，不会对元素位置产生影响；<br>fixed是固定定位，它则以浏览器窗口为参考物，PC网页底部悬停的banner一般都是可以通过fixed定位来实现，但fixed属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动</p><p><strong>6、弹性布局</strong><br>弹性布局即Flex布局，定义了flex容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小；然后当Flex容器被应用一个新尺寸时(width和height),将会自动调整容器中的元素适应新尺寸。Flex容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向(横向和纵向)和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多。注：设为Flex布局后，子元素的float、clear和vertical-align属性将失效.</p><p><strong>7、CSS3动画</strong><br>CSS3中规范引入了两种动画，分别是transition和animation,transition可以让元素的CSS属性值变化在一段时间内平滑的过度，形成动效果，为了使元素的变换更加丰富多彩，CSS3还引入了transfrom属性，它可以通过对元素进行平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew)等操作，来实现2D和3D变化效果。transition还有一个结束事件，transitionEnd,该事件是在CSS完成过渡后触发，如果过渡在完成之前被移除，则不会触发transitionEnd。</p><p><strong>8、Sprite</strong><br>对于大型站点，为了减少http请求次数，一般会将常用的小图标排到一个大图中，页面加载时，只需请求一次网络，然后在css中通过设置background-position来控制显示所有需要的小图标，这就是Sprite图.</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="CSS" scheme="https://pan-rong.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="https://pan-rong.github.io/2018/02/22/HTMLnotes/"/>
    <id>https://pan-rong.github.io/2018/02/22/HTMLnotes/</id>
    <published>2018-02-22T05:34:36.000Z</published>
    <updated>2018-03-05T09:39:25.147Z</updated>
    
    <content type="html"><![CDATA[<p>HTML总体介绍及与HTML5的区别 <a href="https://www.cnblogs.com/zhangyongl/p/6154981.html#undefined" target="_blank" rel="noopener">参考1</a> <a href="http://www.duanliang920.com/learn/web/html5/230.html" target="_blank" rel="noopener">参考2</a><br><a id="more"></a><br><strong>1、BOM</strong><br>    BOM(Browser Object Model)的缩写，及浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局的对象被称为浏览器对象模型，即BOM。BOM的核心对象是window,window对象也是BOM的顶级对象，其中包<br>    含了浏览器6个核心模块(有人说是5个,不包括frames-HTML子框架).</p><pre><code>(1) Document(文档对象)(2) frames-HTML子框架(3) history(4) location(5) navigator(6) screen</code></pre><p><strong>(1) Document(文档对象)</strong><br>    渲染引擎在解析HTML代码时，会为每一个元素生成对应的DOM对象，由于元素之间有层级关系，因此整个HTML代码解析完以后，会生成一个由不同节点组成的树形结构，俗称DOM树，document用于描述DOM树的状态和属性，并提供了很多操作DOM的API.</p><p><strong>(2) frames-HTML子框架</strong><br>    即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文</p><p><strong>(3) history</strong><br>    以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈</p><p><strong>(4) location</strong><br>    提供了当前窗口中加载的文档相关信息以及一些导航功能</p><p><strong>(5) navigator</strong><br>    用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台，用户特性字符串等</p><p><strong>(6) screen</strong><br>    提供了浏览器显示屏幕的相关属性，如：显示屏的宽度和高度，可用宽度和高度</p><p><strong>2、DOM</strong><br>    DOM将HTML和XML文档映射成一个由不同节点组成的树型结构，其核心是document</p><p><strong>3、事件系统</strong><br>事件是用户与页面交互的基础.DOM2.0模型将事件处理流程分为三个阶段：事件捕获阶段、事件处理阶段、事件冒泡阶段<br>    (1)事件捕获：当用户触发点击事件后，顶层对象document就会发出一个事件流，从最外层DOM节点向目标元素节点传递，最终到达目标元素<br>    (2)事件处理：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。<br>    (3)事件冒泡：事件流从目标元素开始，向最外层DOM节点传递，途中如果有节点绑定了事件处理函数，这些函数将会被执行；</p><p>利用事件冒泡原理，可以实现事件委托，所谓委托，就是在父元素上添加监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件，当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素在通过event.targe获取到这个目标元素(之前作品中用this也可以)。这样做的好处是，父元素只需绑定一个事件监听，即可以对所有子元素的事件进行处理，从而减少不必要的事件绑定，对页面性能有一定的提升。</p><p><strong>4、HTML解析过程</strong><br>    (1)浏览器加载html文件<br>    (2)渲染并解析HTML标签，生成DOM节点<br>    (3)渲染并解析CSS样式，生成CSSOM<br>    (4)js脚本处理<br>    (5)将以上打包渲染到浏览器上</p><p><strong>5、重绘和回流</strong><br>    回流：当渲染树中的一部分(或全部)因为元素的规模尺寸、布局、隐藏(主要是display)等改变而需要重新构建；<br>    重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格；而不会影响布局时，就叫重绘；<br>    由此可知，回流必会引起重绘，而重绘不一定会引起回流</p><pre><code>注：transform操作不会引起重绘和回流，是一种高效率的渲染。因为transform属于合成属性，对合成属性进行transition或animation动画时将会创建一个合成层，这使得动画元素在一个独立的层中进行渲染，当元素的内容没有发生改变，就不会重绘和回流。</code></pre><p><strong>6、本地存储</strong><br><strong>(1) cookie</strong><br>    最原始方式，数据以键值对形式保存，可设置过期时间；但不适合大量数据存储；因为每请求一次页面，cookie都会发送给    服务器，因此被限制在4K左右(因浏览器而异)，超出即被忽略，且永不会被设置.</p><p><strong>(2) localStorage和sessionStorage</strong><br>    这是HTML5提供的两种方式，都是以键值对的形式来存储数据；前者是永久存储，后者的存储仅限于浏览器会话(session)。即当浏览器窗口关闭后，sessionStorage中的数据被清除。</p><p>localStorage的存储空间约5M，但在浏览器隐私模式下不可读取，数据超出时会抛异常。</p><p><strong>7、浏览器缓存机制</strong><br>    浏览器缓存机制是通过HTTP协议头里的Cache-Control(或Expires)和Last-Modified(或Etag)等字段来控制文件缓存的机制；Cache-Control用于控制文本在本地缓存有效时长。最常见的，如Cache-Control:max-age=600,表示文件在本地应该缓存，且有效时长为600s.</p><p>Last-Modified是标识文件在服务器上的最新更新时间；若到期，且没有修改，则服务器则返回304告诉浏览器继续用该缓存数据。</p><p><strong>8、History</strong><br>    用户访问网页的历史记录通常会被保存在一个类似于栈的对象中，即history对象，点击返回就出栈，跳下一页就入栈。</p><p><strong>9、Web语义化和SEO</strong><br>    Web语义化是指使用语义恰当的标签，是页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。</p><p>SEO是指了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。</p><p>搜索引擎通过爬虫技术获取的页面就是由一堆html标签组成的代码，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器不行。但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中重要内容，并予以较高的权值。</p><p><strong>10、前端性能优化<a href="http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html" target="_blank" rel="noopener">中文参考</a> <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">英文参考</a></strong><br>提高前端性能可以从以下几个方面入手：<br>(1) 尽量减少HTTP请求数量，如：<br>        图片地图、CSS Sprite、Data URI Scheme(内联资源)、样式表合并、使用Web Font字体图标<br>(2) 缓存，如http头部缓存<br>    <code>&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Tue, 01 Dec 2015 13:30:26 GMT&quot; /&gt;</code><br>    Expires是Web服务器响应消息头字段,在响应http请求时告诉浏览器，若未过期，则直接调缓存.但请求会发生，状态为304，浏览器默认缓存。<br>(3) 使用内容发布网络(CDN使用)//暂时没了解<br>(4)DNS Prefetch //暂时没了解<br>(5)将CSS样式表放在顶部<br>(6)将javascript脚本放在底部<br>(7)使用外部javascript和CSS<br>(8)避免重定向</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="HTML" scheme="https://pan-rong.github.io/tags/HTML/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rong</title>
  
  <subtitle>前端学习者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pan-rong.github.io/"/>
  <updated>2018-03-13T00:58:59.829Z</updated>
  <id>https://pan-rong.github.io/</id>
  
  <author>
    <name>Rong Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flex布局</title>
    <link href="https://pan-rong.github.io/2018/03/11/Flex%E5%B8%83%E5%B1%80/"/>
    <id>https://pan-rong.github.io/2018/03/11/Flex布局/</id>
    <published>2018-03-11T09:09:03.000Z</published>
    <updated>2018-03-13T00:58:59.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><a id="more"></a><h2 id="Flex布局参考1参考2"><a href="#Flex布局参考1参考2" class="headerlink" title="Flex布局参考1参考2"></a>Flex布局<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">参考1</a><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">参考2</a></h2><h2 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h2><p>Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局</p><p>Webkit内核的浏览器，必须加上<code>-webkit</code>前缀</p><p><strong><em>注</em></strong><br>设为Flex布局后，子元素的float,clear 和vertical-align属性将失效。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>容器有6个属性：</p><p>(1) flex-direction : 决定主轴的方向(即项目的排列方向),可取值(row(默认值，水平方向)，row-reverse,column,column-reverse)</p><p>(2) flex-wrap : 决定是否换行，可取值(nowrap[默认值],wrap,wrap-reverse)</p><p>(3) flex-flow : 是flex-direction 和flex-wrap属性的简写形式</p><p>(4) justify-content : 项目在主轴方向上的对齐方式，可取值(flex-start[左对齐，默认],flex-end,center,space-between[两端对齐],space-around[每个项目两侧的间隔相等])</p><p>(5) align-items : 项目在交叉轴上的对齐方式，可取值(flex-start,flex-end,center,baseline[项目的第一行文字的基线对齐],stretch[若项目为设高度或设为auto,将占满整个容器的高度])</p><p>(6) align-content : 定义多根轴线的对齐方式。若项目只有一根轴线，该属性不起作用；可取值(flex-start,flex-end,center,space-between,space-around,stretch[默认值])</p><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><p>项目也有6个属性</p><p>(1) order :定义项目的排列顺序。数值越小，越靠前，默认为0.</p><p>(2) flex-grow :定义放大比例，默认为0，即若存在剩余空间，也不放大 </p><p>(3) flex-shrink ：定义项目缩小比例，默认为1，若空间不足，该项目将缩小。</p><p>(4) flex-basis ：定义在分配多余空间之前，项目占据的主轴空间，默认为auto,即项目本来大小</p><p>(5) flex ：是flex-grow,flex-shrink,flex-basis的简写，默认是 0 1 auto.后两个属性可选。</p><p>(6) align-self ：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto.表示继承父元素的align-items。若没有父元素，则等同于stretch。可取值(auto,flex-start.flex-end,center,baseline,stretch);</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="css" scheme="https://pan-rong.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JS获取页面、屏幕尺寸</title>
    <link href="https://pan-rong.github.io/2018/03/07/JS%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8/"/>
    <id>https://pan-rong.github.io/2018/03/07/JS获取屏幕尺寸/</id>
    <published>2018-03-07T02:58:21.000Z</published>
    <updated>2018-03-13T01:03:02.019Z</updated>
    
    <content type="html"><![CDATA[<p>JS获取页面、屏幕尺寸<a href="http://www.cnblogs.com/rushoooooo/archive/2011/05/01/2033670.html" target="_blank" rel="noopener">参考原文</a><br><a id="more"></a><br>在设计网页时，经常会用到获取元素的位置信息，下面来说下盒子模型，从外往内一次为：<code>offset</code>、<code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>；</p><p>注：盒子的宽度和高度不受margin、border、padding的设置而变化</p><p><strong>以下是介绍JS获取屏幕、浏览器窗口、页面等的高度、宽度大小；</strong><br>(1) 网页可见区域宽：<code>document.body.clientWidth</code>;(随屏幕大小变化)<br>(2) 网页可见区域高：<code>document.body.clientHeight</code>;(随可见屏幕高度变化)<br>(3) 网页可见区域宽：<code>document.body.offsetWidth</code>(包括边线的宽,但不包括body的margin)<br>(4) 网页可见区域高：<code>document.body.offsetHeight</code> (包括边线的宽,但不包括body的margin)<br>(5) 网页正文全文宽：<code>document.body.scrollWidth</code> (即html所包含的全部宽度，若设置自适应，就是自适应的宽度)<br>(6) 网页正文全文高：<code>document.body.scrollHeight</code>(即html所包含的全部高度，若设置自适应，就是自适应的高度)<br>(7) 网页被卷去的高：<code>document.body.scrollTop</code>(看滚轮的位置)<br>(8) 网页被卷去的左：<code>document.body.scrollLeft</code>(看滚轮的位置)<br>(9) 网页正文部分上：<code>window.screenTop</code>(即你打开的网页距离你电脑屏幕的上方的距离)<br>(10) 网页正文部分左：<code>window.screenLeft</code>(同上，但是与左边的距离)<br>(11) 屏幕分辨率的高：<code>window.screen.height</code> (屏幕的高度，随设备变化)<br>(12) 屏幕分辨率的宽：<code>window.screen.width</code>(屏幕的宽度，随设备变化)<br>(13) 屏幕可用工作区高度：<code>window.screen.availHeight</code><br>(14) 屏幕可用工作区宽度：<code>window.screen.availWidth</code></p><p><strong>HTML精确定位:<code>scrollLeft</code>,<code>scrollWidth</code>,<code>clientWidth</code>,<code>offsetWidth</code></strong><br><code>scrollHeight</code>: 获取对象的滚动高度。<br><code>scrollLeft</code>:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离<br><code>scrollTop</code>:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离<br><code>scrollWidth</code>:获取对象的滚动宽度<br><code>offsetHeight</code>:获取对象相对于版面或由父坐标<code>offsetParent</code>属性指定的父坐标的高度<br><code>offsetLeft</code>:获取对象相对于版面或由<code>offsetParent</code>属性指定的父坐标的计算左侧位置<br><code>offsetTop</code>:获取对象相对于版面或由<code>offsetTop</code>属性指定的父坐标的计算顶端位置<br><code>event.clientX</code> 相对文档的水平坐标<br><code>event.clientY</code> 相对文档的垂直坐标<br><code>event.offsetX</code> 相对容器的水平坐标<br><code>event.offsetY</code> 相对容器的垂直坐标<br><code>document.documentElement.scrollTop</code> 垂直方向滚动的值<br><code>event.clientX+document.documentElement.scrollTop</code> 相对文档的水平座标+垂直方向滚动的量</p><p><strong>IE，FireFox 差异如下：</strong><br><strong><em>IE6.0、FF1.06+：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clientWidth = width + padding</span><br><span class="line">clientHeight = height + padding</span><br><span class="line">offsetWidth = width + padding + border</span><br><span class="line">offsetHeight = height + padding + border</span><br></pre></td></tr></table></figure></p><p><strong><em>IE5.0/5.5：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clientWidth = width - border</span><br><span class="line">clientHeight = height - border</span><br><span class="line">offsetWidth = width</span><br><span class="line">offsetHeight = height</span><br></pre></td></tr></table></figure></p><p>注：<br>(1) CSS中的<code>margin</code>属性，与<code>clientWidth</code>、<code>offsetWidth</code>、<code>clientHeight</code>、<code>offsetHeight</code>均无关<br>(2) <code>div.style.top</code>：相对于<code>div</code>所在的元件的顶部距离</p><p><strong>技术要点</strong><br>本节代码主要使用了<code>Document</code>对象关于窗口的一些属性，这些属性的主要功能和用法如下。<br>要得到窗口的尺寸，对于不同的浏览器，需要使用不同的属性和方法：若要检测窗口的真实尺寸，在Netscape下需要使用<code>Window</code>的属性；在 <code>IE</code>下需要深入<code>Document</code>内部对<code>body</code>进行检测；在<code>DOM</code>环境下，若要得到窗口的尺寸，需要注意根元素的尺寸，而不是元素。<br><code>Window</code>对象的<code>innerWidth</code>属性包含当前窗口的内部宽度。<code>Window</code>对象的<code>innerHeight</code>属性包含当前窗口的内部高度。<br><code>Document</code>对象的<code>body</code>属性对应<code>HTML</code>文档的标签。<code>Document</code>对象的<code>documentElement</code>属性则表示<code>HTML</code>文档的根节点。<br><code>document.body.clientHeight</code>表示<code>HTML</code>文档所在窗口的当前高度。<code>document.body. clientWidth</code>表示<code>HTML</code>文档所在窗口的当前宽度。<br>浏览器大小调整事件<br><code>window.onresize=funName</code>;//当浏览器大小发生变化时调用<code>funName</code>函数</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="JS" scheme="https://pan-rong.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局讲解float、flex使用</title>
    <link href="https://pan-rong.github.io/2018/03/06/CSS%E4%B8%ADfloat/"/>
    <id>https://pan-rong.github.io/2018/03/06/CSS中float/</id>
    <published>2018-03-06T07:47:10.000Z</published>
    <updated>2018-03-06T08:12:12.280Z</updated>
    
    <content type="html"><![CDATA[<p>#CSS中的float、flex的使用<br><a id="more"></a><br>实现右边宽度固定，左边自适应<br>示例1(使用float实现)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"> body&#123;</span><br><span class="line">    width: auto; /*width:100%;*/</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: #0ff;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    width: 300px;</span><br><span class="line">    float: right;</span><br><span class="line">    background: #ff0;</span><br><span class="line">&#125;   </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p><code>float</code>在使用时，要注意，设置<code>float: right</code>时，若空间充裕，该代码的下一行将和被设置行在同一行；而不是被设置行和上一代码行同行。所以，实现右边宽度固定，左边自适应时，需要将自适应的那行写在下面。</p><p>示例2(使用flex实现)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body&#123;</span><br><span class="line">        display:flex;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        height:200px;</span><br><span class="line">        flex:1;</span><br><span class="line">        background:#0ff;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        height:200px;</span><br><span class="line">        width:300px;</span><br><span class="line">        background:#ff0;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>示例讲解：<br>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局（包括行内元素）。</p><p>行内元素也可以使用Flex布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;  display: inline-flex;&#125;</span><br></pre></td></tr></table></figure></p><p>Webkit内核的浏览器，必须加上-webkit前缀:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注: 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p><p>容器的属性:<br>以下6个属性设置在容器上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-direction //flex-direction属性决定主轴的方向（即项目的排列方向</span><br><span class="line">flex-wrap //flex-wrap属性定义，如果一条轴线排不下，如何换行</span><br><span class="line">flex-flow //是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</span><br><span class="line">justify-content //定义了项目在主轴上的对齐方式</span><br><span class="line">align-items  //定义项目在交叉轴上如何对齐</span><br><span class="line">align-content //定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="css" scheme="https://pan-rong.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>meta标签-IE兼容</title>
    <link href="https://pan-rong.github.io/2018/03/06/meta%E6%A0%87%E7%AD%BE-IE%E5%85%BC%E5%AE%B9/"/>
    <id>https://pan-rong.github.io/2018/03/06/meta标签-IE兼容/</id>
    <published>2018-03-06T07:16:10.000Z</published>
    <updated>2018-03-06T07:32:09.061Z</updated>
    
    <content type="html"><![CDATA[<p>#meta标签-IE兼容<a href="http://www.cnblogs.com/chendc/p/5423337.html" target="_blank" rel="noopener">参考1</a> <a href="http://www.cnblogs.com/nidilzhang/archive/2010/01/09/1642887.html" target="_blank" rel="noopener">参考2</a><br><a id="more"></a><br>在平时的写网页代码时，一般都会写下面这段代码，是什么作用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><code>X-UA-Compatible</code>是<code>IE8</code>的一个专有<code>&lt;meta&gt;</code>属性，它告诉<code>IE8</code>采用何种<code>IE</code>版本去渲染网页;当<code>content</code>写成等于<code>ie=edge</code>时，模式<code>Edge</code>模式告诉<code>IE</code>以最高级模式渲染文档，也就是任何<code>IE</code>版本都以当前版本所支持的最高级标准模式渲染，避免版本升级造成的影响.</p><p>使用以下代码强制 <code>IE</code> 使用 <code>Chrome Frame</code> 渲染<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=1&quot;&gt;</code></p><p>最佳的兼容模式方案：<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code></p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="javascript" scheme="https://pan-rong.github.io/tags/javascript/"/>
    
      <category term="meta" scheme="https://pan-rong.github.io/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>meta中的viewport指令</title>
    <link href="https://pan-rong.github.io/2018/03/06/meta%E4%B8%AD%E7%9A%84viewport%E6%8C%87%E4%BB%A4/"/>
    <id>https://pan-rong.github.io/2018/03/06/meta中的viewport指令/</id>
    <published>2018-03-06T06:53:10.000Z</published>
    <updated>2018-03-06T07:15:26.410Z</updated>
    
    <content type="html"><![CDATA[<p>#meta中的viewport指令<a href="http://www.cnblogs.com/ubunoon/archive/2012/07/27/2612243.html" target="_blank" rel="noopener">参考</a><br><a id="more"></a><br>我们常常在html的head里看到如下代码行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>viewport<meta>标记用于指定用户是否可以缩放Web页面，同时还表示文档针对移动设备进行了优化。若选择可以缩放Web页面，需要写明缩放比例。</p><p>viewport<meta>标记的content值是由指令及其值组成的，以逗号分隔的列表。</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=”viewport” content=”width=240, height=320, user-scalable=yes, initial-scale=2.5, maximum-scale=5.0, minimun-scale=1.0”&gt;</span><br></pre></td></tr></table></figure></p><p><code>width</code>和<code>height</code>指令分别指定视区的逻辑宽度和高度。他们的值要么是以像素为单位的数字，要么是一个特殊的标记符号。<code>width</code>指令使用<code>device-width</code>标记可以指示视区宽度应为设备的屏幕宽度。类似地<code>height</code>指令使用<code>device-height</code>标记指示视区高度为设备的屏幕高度。</p><p><code>user-scalable</code>指令指定用户是否可以缩放视区，即缩放<code>Web</code>页面的视图。值为<code>yes</code>时允许用户进行缩放，值为<code>no</code>时不允许缩放.</p><p><code>initial-scale</code>指令用于设置<code>Web</code>页面的初始缩放比例。默认的初始缩放比例值因智能手机浏览器的不同而有所差异。通常情况下设备会在浏览器中呈现出整个<code>Web</code>页面，设为<code>1.0</code>则将显示未经缩放的<code>Web</code>文档.</p><p><code>maximum-scale</code>和<code>minimum-scale</code>指令用于设置用户对<code>Web</code>页面缩放比例的限制。值的范围为<code>0.25</code>至<code>10.0</code>之间。与<code>initial-scale</code>相同，这些指令的值是应用于视区内容的缩放比例.</p><p>所有智能手机浏览器都支持<code>ViewPort &lt;meta&gt;</code>标记的<code>width</code>和<code>user-scalabel</code>指令。但是<code>Opera Mobile</code>不使用<code>user-scalable</code>指令，而是主张用户应始终保留在移动浏览器中缩放<code>Web</code>页面的能力.</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="javascript" scheme="https://pan-rong.github.io/tags/javascript/"/>
    
      <category term="meta" scheme="https://pan-rong.github.io/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>跨域请求整理</title>
    <link href="https://pan-rong.github.io/2018/03/05/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%95%B4%E7%90%86/"/>
    <id>https://pan-rong.github.io/2018/03/05/跨域请求整理/</id>
    <published>2018-03-05T10:55:20.000Z</published>
    <updated>2018-03-05T11:16:02.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域总结参考1-参考2"><a href="#跨域总结参考1-参考2" class="headerlink" title="跨域总结参考1,参考2"></a>跨域总结<a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">参考1</a>,<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">参考2</a></h1><a id="more"></a><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨越是广义的。</p><p>广义跨域：</p><pre><code>(1)资源跳转：A链接、重定向、表单提交(2)资源嵌入：&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、    @font-face()等文件外链；(3)脚本请求：js发起的ajax请求、dom和js对象的跨域操作等</code></pre><p>我们常说的跨越是狭义的，是浏览器执行其他网站的脚本，是由浏览器同源策略限制的一类请求场景。</p><p><strong>同源策略</strong></p><pre><code>同源策略即：协议+域名+端口，三者相同，即便两个不同的域名指向同一个IP地址，也非同源(同一域名，不同文件或路径可以)</code></pre><p>同源策略限制以下几种行为：</p><pre><code>(1) Cookie、LocalStorage和IndexDB无法读取(2) DOM和JS对象无法获得(3) AJAX请求不能发送</code></pre><h2 id="跨越解决方案"><a href="#跨越解决方案" class="headerlink" title="跨越解决方案"></a>跨越解决方案</h2><pre><code>(1) 通过jsonp跨越(2) 跨域资源共享(cors)(3) document.domain+iframe跨域(4) location.hash+iframe(5) window.name+iframe跨越(6) postMessage跨域(7) nginx代理跨域(8) nodejs中间件代理跨域(9) WebSocket协议跨域</code></pre><p>本次只整理前两种：</p><p><strong>(1) 通过jsonp跨域</strong></p><p>通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p>1) 原生实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    script.type = &apos;text/javascript&apos;;</span><br><span class="line">    // 传参并指定回调执行函数为onBack    </span><br><span class="line">    script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&apos;;</span><br><span class="line">    document.head.appendChild(script);//向head里添加script</span><br><span class="line">    // 回调执行函数</span><br><span class="line">    function onBack(res) &#123;</span><br><span class="line">        alert(JSON.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p> 2) jQuery AJAX:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&apos;http://www.domain2.com:8080/login&apos;,</span><br><span class="line">    type:&apos;get&apos;,</span><br><span class="line">    dataType:&apos;jsonp&apos;,</span><br><span class="line">    jsonpCallback:&apos;onBack&apos;,</span><br><span class="line">    data:&#123;&#125;//</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p> 3) vue js:(没用过，不是很懂)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;,&#123;</span><br><span class="line">    params:&#123;&#125;,</span><br><span class="line">    jsonp:&apos;onBack&apos;</span><br><span class="line">&#125;).then((res)=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>后端node.js代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var querystring=require(&apos;querystring&apos;);</span><br><span class="line">var http=require(&apos;http&apos;);</span><br><span class="line">var server=http.createServer();</span><br><span class="line">server.on(&apos;request&apos;,function(req,res)&#123;</span><br><span class="line">    var params=qs.parse(req.url.split(&apos;?&apos;)[1]); </span><br><span class="line">    var fn=params.callback;</span><br><span class="line">    //jsonp返回设置</span><br><span class="line">    res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/javascript&apos;&#125;);</span><br><span class="line">    res.write(fn+&apos;(&apos;+JSON.stringify(params)+&apos;)&apos;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;&apos;);</span><br></pre></td></tr></table></figure></p><p>jsonp缺点：只能实现get一种请求。</p><p><strong>(2) 跨域资源共享(CORS)</strong></p><p><strong><em>简介</em></strong></p><p>目前主流的跨域解决方案。CORS是一个W3C标准，它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAx</code>只能同源使用的限制。CORS需要浏览器和服务器同时支持，目前，所有浏览器都支持该功能(IE不低于IE10)。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><p><strong><em>CORS两种请求</em></strong></p><p>一种是简单请求，另一种是非简单请求。只要满足下面条件就是简单请求：</p><pre><code>1) 请求方式为HEAD、POST 或者 GET2) http头信息不超出一下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、    Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain)</code></pre><p>为什么要分为简单请求和非简单请求，因为浏览器对这两种请求方式的处理方式是不同的。</p><p><strong>简单请求</strong></p><p><strong><em>基本流程</em></strong></p><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</p><pre><code>注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。有三个与CORS请求相关的字段，都以Access-Control-开头：1) Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接   受任意域名的请求2) Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie.默认情况   下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务   器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。  3) Access-Control-Expose-Headers:该字段可选. CORS请求时，XMLHttpRequest对象的getResponseHeader()方   法只能拿到6个基本字段:Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、   Pragma.如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</code></pre><p><code>withCredentials</code>属性</p><p>上面说到，<code>CORS</code>请求默认不发送<code>Cookie</code>和<code>HTTP</code>认证信息。如果要把<code>Cookie</code>发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><p>另一方面，开发者必须在<code>AJAX</code>请求中打开<code>withCredentials</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容</span><br><span class="line">    // 前端设置是否带cookie</span><br><span class="line">    xhr.withCredentials = true;</span><br><span class="line">    xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);</span><br><span class="line">    xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">    xhr.send(&apos;user=admin&apos;);</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">         if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">             alert(xhr.responseText);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // jquery</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">       ...</span><br><span class="line">       xhrFields: &#123;</span><br><span class="line">          withCredentials: true // 前端设置是否带cookie</span><br><span class="line">       &#125;,</span><br><span class="line">       crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie</span><br><span class="line">        ...</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></p><p>否则，即使服务器同意发送<code>Cookie</code>，浏览器也不会发送。或者，服务器要求设置<code>Cookie</code>，浏览器也不会处理。但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送<code>Cookie</code>。这时，可以显式关闭<code>withCredentials</code>。</p><p>需要注意的是，如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，其他域名的<code>Cookie</code>并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><p><strong>非简单请求</strong></p><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的<code>CORS</code>请求，会在正式通信之前，增加一次<code>HTTP</code>查询请求，称为”预检”请求（preflight）</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些<code>HTTP</code>动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">    xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">    xhr.send();</span><br></pre></td></tr></table></figure></p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。</p><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段:</p><pre><code>1) Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS,请求会用到哪些HTTP方法，上例是PUT。2) Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段.  上例是X-Custom-Header.</code></pre><p>预检请求的回应</p><pre><code>服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应.如果浏览器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</code></pre><p>服务器回应的其他CORS相关字段如下：</p><pre><code>1) Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的   方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求.2) Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则   Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，   不限于浏览器在&quot;预检&quot;中请求的字段。3) Access-Control-Allow-Credentials： 该字段与简单请求时的含义相同.4) Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天  （1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</code></pre><p>浏览器正常请求回应</p><pre><code>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。浏览器的正常CORS请求。上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。Access-Control-Allow-Origin字段是每次回应都必定包含的.</code></pre><p><strong><em>JSONP和CORS对比</em></strong></p><pre><code>CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</code></pre>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="AJAX" scheme="https://pan-rong.github.io/tags/AJAX/"/>
    
      <category term="CORS" scheme="https://pan-rong.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>NPM学习笔记</title>
    <link href="https://pan-rong.github.io/2018/03/05/NPMnotes/"/>
    <id>https://pan-rong.github.io/2018/03/05/NPMnotes/</id>
    <published>2018-03-05T09:40:21.000Z</published>
    <updated>2018-03-05T10:43:35.774Z</updated>
    
    <content type="html"><![CDATA[<p>NPM使用介绍(window 系统)<a href="https://www.npmjs.com/" target="_blank" rel="noopener">官网</a><br><a id="more"></a></p><h1 id="NPM使用介绍-window-系统-官网"><a href="#NPM使用介绍-window-系统-官网" class="headerlink" title="NPM使用介绍(window 系统)官网"></a>NPM使用介绍(window 系统)<a href="https://www.npmjs.com/" target="_blank" rel="noopener">官网</a></h1><h2 id="NPM的使用场景"><a href="#NPM的使用场景" class="headerlink" title="NPM的使用场景"></a>NPM的使用场景</h2><p>NPM随同Node JS一起安装的包管理工具，能解决Node JS代码部署上的很多问题，常见的应用场景：</p><p>(1) 允许用户从NPM服务器下载别人编写的第三方包到本地使用</p><p>(2) 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用</p><p>(3) 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</p><p>首先测试随Node JS一起安装的NPM版本，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure></p><p>升级该NPM版本的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g npm</span><br></pre></td></tr></table></figure></p><p>其次，查看程序的默认配置，方便以后找文件：</p><p>npm config 的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm config set &lt;key&gt; &lt;value&gt;</span><br><span class="line">npm config get [&lt;key&gt;]</span><br><span class="line">npm config delete &lt;key&gt;</span><br><span class="line">npm config list [--json]</span><br><span class="line">npm config edit</span><br><span class="line">npm set &lt;key&gt; &lt;value&gt;</span><br><span class="line">npm get [&lt;key&gt;]</span><br></pre></td></tr></table></figure></p><p>使用以下命令可以看到常用的配置列表，如（默认文件存储位置和缓存位置，）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure></p><p>一般情况下，npm的默认文件位置和缓存位置都在C盘，可以修改，例：修改默认配置的方法(注意是双斜杠)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;F:\\NPM\\prefix&quot;</span><br></pre></td></tr></table></figure></p><p>上述配置后，就将文件的存储位置改了，可以用以下代码验证，是否成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure></p><p>然后就可以安装你想要的模块了(若不需要修改默认路径，则可以不用上述操作)</p><p>在命令窗口，打开子文件夹的方法“cd 子文件夹”;</p><p>返回上层文件夹用“../”;</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="NPM" scheme="https://pan-rong.github.io/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记</title>
    <link href="https://pan-rong.github.io/2018/03/03/ES6notes/"/>
    <id>https://pan-rong.github.io/2018/03/03/ES6notes/</id>
    <published>2018-03-03T06:30:02.000Z</published>
    <updated>2018-03-05T10:36:24.469Z</updated>
    
    <content type="html"><![CDATA[<p>ES6简介<br>ES6是ES5的升级，它们都是JS编程语言现今的最大更新。95年出现了JS语言。<br><a id="more"></a><br>以下从4个方面讲解ES6新增：1.语法 2.函数 3.内置功能 4.开发者工具</p><p>1.语法：</p><pre><code>新增(1) 变量let和const;(2) 模板字面量;(3) 解构;(4) 对象字面量简写法;(5) 迭代;(6) 展开...运算符;(7) 剩余参数;</code></pre><p>2.函数：</p><pre><code>新增(1) 箭头函数;(2) 函数里新增默认函数参数;(3) JS中的类(和ES5有区别)</code></pre><p>3.内置功能：</p><pre><code>新增(1) Symbol(标识符);(2) Set(集合);(3) WeakSet(弱集合);(4) Map(映射);(5) WeakMap(弱映射);(6) Promise(异步); (7) Proxy(代理);(8) 生成器(generator);</code></pre><p>4.开发者工具:</p><pre><code>(1) Polyfill;(2) Babel(JS转译器)</code></pre><h2 id="1-语言上的新增"><a href="#1-语言上的新增" class="headerlink" title="1.语言上的新增"></a>1.语言上的新增</h2><p><strong>(1) 变量let和const</strong><br>两种新的方式来声明变量：let和const；它们的作用域是到块(即用花括号表示)，而不是函数，不会提升；而var会提升到全局作用域或本地作用域即整个函数作用域。</p><p>在代码块中使用let和const声明变量，该变量会陷入暂时性死区，直到该变量的声明被处理；这种行为会阻止变量被访问，除非它们被声明了。</p><p>let和const的规则</p><pre><code>使用let声明的变量可以重新赋值，但是不能在同一作用域内重新声明使用const声明的变量必须赋初始值，但是不能在同一作用域内重新声明，也无法重新赋值。</code></pre><p><strong>(2) 模板字面量</strong><br>ES6引入了模板字面量(在ES6开发版本中叫“模板字符串”)，其本质上是包含嵌入式表达式的字符串字面量。</p><p>模板字面量是用倒引号(<code></code>)表示，可以包含用${expression}表示的占位符，且将换行符当成字符串的一部分。</p><p>模板字面量中的嵌入式表达式不仅仅可以用来引用变量。你可以在嵌入式表达式中进行运算、调用函数和使用循环。</p><p><strong>(3) 解构</strong><br>在ES6中，可以使用解构从数组和对象中提取值并赋给独特的变量。</p><p>解构：从Perl和Python等语言中获得灵感，使你能够指定要从赋值左侧上的数组或对象中提取的元素。<br>例1 解构数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const point = [10, 25, -34];</span><br><span class="line">const [x, y, z] = point;</span><br><span class="line">console.log(x, y, z);</span><br><span class="line">Prints: 10 25 -34</span><br></pre></td></tr></table></figure></p><p>上述中，方括号 [ ] 表示被解构的数组，x、y 和 z 表示要将数组中的值存储在其中的变量。注意，你不需要指定要从中提取值的索引，因为索引可以暗示出来。</p><p>例2 解构对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const gemstone = &#123;</span><br><span class="line">type: &apos;quartz&apos;,</span><br><span class="line">color: &apos;rose&apos;,</span><br><span class="line">karat: 21.29</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;type, color, karat&#125; = gemstone;</span><br><span class="line">console.log(type, color, karat);</span><br><span class="line">Prints: quartz rose 21.29</span><br></pre></td></tr></table></figure></p><p>上述中，花括号 { } 表示被解构的对象，type、color 和 karat 表示要将对象中的属性存储到其中的变量。因为 gemstone具有 type 属性，值自动存储在 type 变量中。</p><p> <strong>(4) 对象字面量简写法</strong><br>在删掉不必要重复代码中，ES6推出了新简写法，例：</p><p>对象字面量简写法：<br>用来初始化对象并向对象中添加方法，使用和所分配的变量名称相同的名称初始化对象，可重对象属性中删除该属性。</p><p>对象中简写方法名称：<br>对象中添加方法时，可以省掉function关键字</p><p> <strong>(5) 迭代</strong><br>(1)、ES6中添加了一个新的可迭代接口，它允许我们自定义对象的迭代方式(即循环遍历方式)，<br>(2)、ES6中新增了一个循环，即for…of..,专门遍历可迭代对象(即实现了这个新迭代接口的对象，如string，array，Map和Set)</p><pre><code>for...of循环(优势)循环访问任何可迭代的数据类型，和for...in相似，但可以忽略索引(代码最简)；且可随时停止或退出for...of循环；不用担心向对象中添加新属性，for...of循环只循环访问对象中的值。</code></pre><p><strong>(6) 展开…运算符</strong><br>ES6中新增了展开运算符(用三个连续的点…表示)，可将字面量对象展开为多个元素<br>例1 展开集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);</span><br><span class="line">console.log(...primes);</span><br><span class="line">Prints: 2 3 5 7 11 13 17 19 23 29</span><br></pre></td></tr></table></figure></p><p>例2 结合数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;pears&quot;];</span><br><span class="line">const vegetables = [&quot;corn&quot;, &quot;potatoes&quot;, &quot;carrots&quot;];</span><br><span class="line">//const produce = fruits.concat(vegetables);</span><br><span class="line">const produce = [...fruits,...vegetables];</span><br><span class="line">console.log(produce);</span><br><span class="line">Prints: [&quot;apples&quot;, &quot;bananas&quot;, &quot;pears&quot;, &quot;corn&quot;, &quot;potatoes&quot;, &quot;carrots&quot;]</span><br></pre></td></tr></table></figure></p><p><strong>(7) 剩余参数</strong><br>ES6中新增的另一个运算符，剩余参数也用三个连续点…表示，使你能够将不定数量的元素表示为数组。<br>例1、将变量赋数组值时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const order = [20.17, 18.67, 1.50, &quot;cheese&quot;, &quot;eggs&quot;, &quot;milk&quot;, &quot;bread&quot;];</span><br><span class="line">const [total, subtotal, tax, ...items] = order;</span><br><span class="line">console.log(total, subtotal, tax, items);</span><br><span class="line">Prints: 20.17 18.67 1.5 [&quot;cheese&quot;, &quot;eggs&quot;, &quot;milk&quot;, &quot;bread&quot;]</span><br></pre></td></tr></table></figure></p><p>例2、可变参数函数(即接受不定数量参数的函数)<br>在此之前可使用参数对象(arguments),现在可以使用剩余参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(...nums) &#123;</span><br><span class="line">  let total = 0;  </span><br><span class="line">  for(const num of nums) &#123;</span><br><span class="line">    total += num;</span><br><span class="line">  &#125;</span><br><span class="line">  return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-函数新增"><a href="#2-函数新增" class="headerlink" title="2.函数新增"></a>2.函数新增</h2><p><strong>(1) 箭头函数(箭头函数表达式)</strong><br>ES6新增函数，箭头函数，例,转换数组中的大小写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const upperizedNames = [&apos;Farrin&apos;, &apos;Kagure&apos;, &apos;Asser&apos;].map(</span><br><span class="line">    name =&gt; name.toUpperCase()</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><pre><code>将“普通”函数转换成箭头函数的步骤：1.删掉关键字 function2.删掉圆括号3.删掉左右花括号4.删掉关键字 return5.删掉分号6.在参数列表和函数主体之间添加一个箭头（=&gt;）</code></pre><p>箭头函数和普通函数的区别：</p><pre><code>普通函数可以是函数声明或函数表达式，但箭头函数始终是表达式；所以仅在表达式有效时才能使用箭头函数，如：1.存储在变量中2.当做参数传递给函数3.存储在对象的属性中参数列表出现在箭头函数的箭头(=&gt;)前面，当只有一个参数时，可以直接写参数名；若有多个或零个，则需要用圆括号。当箭头函数的函数主体只有一个表达式时，在函数主体周围没有花括号；自动返回表达式当函数主体需多行代码时，需将函数主体放在花括号内，需要使用return语句来返回内容.</code></pre><p>“this”在普通函数和箭头函数中的使用</p><pre><code>在普通函数中，this取决于它的函数(或方法)是如何被调用的，例：1.新的对象(使用new调用)，则构造函数中的this的值是新的对象2.指定的对象(使用call或apply调用)  注：call和apply的区别，call方法接受的是若干个参数的列表；而apply方法接受的是一个      包含多个参数的数组。3.上下文对象(即点符号左边的对象)4.全局对象或undefined  以上三种情况都不存在是，函数中的this的值是全局对象，在严格模式下是undefined在箭头函数中的this:箭头函数中，this的值基于函数周围的上下文，即this的值与函数外面的this的值一样</code></pre><p> <strong>(2) 默认函数参数</strong><br>ES6中新的方式创建默认值，即默认函数参数；<br>要创建默认参数，需要添加等号(=)以及当参数未提供时参数应该设为默认值，其可以为任何JS数据类型</p><p>当默认函数参数和解构一起使用时，战斗力提升好几倍~ 例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createGrid([width = 5, height = 5] = []) &#123;</span><br><span class="line">  return `Generating a grid of $&#123;width&#125; by $&#123;height&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">createGrid(); // Generates a 5 x 5 grid</span><br><span class="line">Returns: Generates a 5 x 5 grid</span><br></pre></td></tr></table></figure></p><p><strong>(3) JS中的类</strong><br>JS不是基于类的语言，它使用函数来创建对象，并通过原型将它们关联在一起。所谓的JS类本质上还是一样的。</p><p>ES5中的类</p><pre><code>1.构造函数使用new关键字被调用2.按照惯例，构造函数名以大写字母开头3.构造函数控制将被创建的对象的数据的设置4.“继承”的方法被放在构造函数的原型对象上</code></pre><p>ES6中类,新类的编写：(注：类里各函数之间不要逗号)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Plane &#123;</span><br><span class="line">  constructor(numEngines) &#123;</span><br><span class="line">    this.numEngines = numEngines;</span><br><span class="line">    this.enginesActive = false;</span><br><span class="line">   &#125;</span><br><span class="line">    startEngines() &#123;</span><br><span class="line">      console.log(&apos;starting engines…&apos;);</span><br><span class="line">      this.enginesActive = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//以下是ES5中的startEngines定义,且ES5中类定义没有构造器函数，像普通函数一样定义</span><br><span class="line">//Plane.prototype.startEngines = function () &#123;</span><br><span class="line">//  console.log(&apos;starting engines...&apos;);</span><br><span class="line">//  this.enginesActive = true;</span><br><span class="line">//&#125;;</span><br></pre></td></tr></table></figure></p><p>ES6中的子类<br>在ES6中，使用super和extends关键字扩展类；</p><pre><code>关键字extends将自己设为子类，要让子类可以访问到父类，需要使用关键字super。super既可被用作函数，也可被用作对象，但是super必须在this之前被调用，</code></pre><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Tree &#123;</span><br><span class="line">    constructor(size = &apos;10&apos;, leaves = &#123;spring: &apos;green&apos;, summer: &apos;green&apos;, fall: &apos;orange&apos;, winter: null&#125;) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.leaves = leaves;</span><br><span class="line">        this.leafColor = null;</span><br><span class="line">    &#125;</span><br><span class="line">    changeSeason(season) &#123;</span><br><span class="line">        this.leafColor = this.leaves[season];</span><br><span class="line">        if (season === &apos;spring&apos;) &#123;</span><br><span class="line">        this.size += 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Maple extends Tree &#123;</span><br><span class="line">    constructor(syrupQty = 15, size, leaves) &#123;</span><br><span class="line">        super(size, leaves);</span><br><span class="line">        this.syrupQty = syrupQty;</span><br><span class="line">    &#125;</span><br><span class="line">    changeSeason(season) &#123;</span><br><span class="line">        super.changeSeason(season);</span><br><span class="line">        if (season === &apos;spring&apos;) &#123;</span><br><span class="line">            this.syrupQty += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gatherSyrup() &#123;</span><br><span class="line">        this.syrupQty -= 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-ES6新增内置功能"><a href="#3-ES6新增内置功能" class="headerlink" title="3.ES6新增内置功能"></a>3.ES6新增内置功能</h2><p><strong>(1) Symbol(标识符)</strong><br>Symbol 只是一个唯一标识符，最常用于唯一标识对象中的属性(如对象中属性的名字相同但value不同时).但是不能用来访问标识符本身。</p><p>Symbol的创建：Symbol(),并添加一个可选的字符串作为其描述。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&apos;apple&apos;);</span><br><span class="line">console.log(sym1);//Symbol(apple)</span><br></pre></td></tr></table></figure></p><p><strong>(2) 迭代器协议和可迭代协议(不是ES6内置)</strong><br>ES6中新增的两个协议：迭代器协议和可迭代协议</p><p>其中，可迭代协议用来定义和自定义对象的迭代行为；工作原理：为了使对象可迭代，它必须实现可迭代接口(即必须包含默认的迭代器方法)。</p><p>迭代器协议用来定义对象生成一系列值的标准方式；即定义对象如何迭代的流程。工作原理：<br>    通过执行.next() 方法来完成这一流程。next()方法是无参数函数，返回具有两个属性的<br>    对象：value(下个值数据)和done(为false继续迭代，为true达到末尾);</p><p><strong>(3) Set(集合、单值、ES6内置可迭代)</strong><br>Set()数学意义上的集合，即每个数字都是唯一的，只出现一次；不基于索引，不可单独被访问.</p><p>Set创建：new  Set();</p><p>Set修改：</p><pre><code>.add()增加，.delete()删除，.clear()清除注：若增加时，条目重复，则Set中不增加(返回Set对象)；若删除时，条目没有，则不删除(成功返回true,失败返回false)</code></pre><p>Set使用：</p><pre><code>.size返回条目数；.has()检查Set中是否存在某个条目，若有返回true，没有返回false.values()返回Set中的SetIterator对象，即所有值；.keys()同.values()</code></pre><p>Set循环访问：</p><pre><code>1.使用SetIterator和.next()访问Set中的每一项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const iterator = months.values();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure>2.使用for...of循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const colors = new Set([&apos;red&apos;, &apos;orange&apos;, &apos;yellow&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;violet&apos;, &apos;brown&apos;, &apos;black&apos;]);</span><br><span class="line">for (const color of colors) &#123;</span><br><span class="line">    console.log(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><strong>(4) WeakSet(弱集合)</strong><br>WeakSet和Set的区别：</p><pre><code>1.WeakSet只能包含对象；2.WeakSet无法迭代，不能循环访问3.WeakSet没有.clear()方法</code></pre><p>WeakSet创建：new WeakSet();</p><p>垃圾回收：</p><pre><code>JS中创建新值会分配内存，当这些值不需要时，将自动释放内存。该过程就称为垃圾回收WeakSet 通过专门使用对象作为键值来利用这一点。如果将对象设为 null，则本质上是删除该对象，当 JS 的垃圾回收器运行时，该对象之前占用的内存将被释放，以便稍后在程序中使用。</code></pre><p><strong>(5) Map(映射)</strong><br>Map是一个可以存储键值对的对象，键和值都可以是对象、原始值或二者的结合。</p><p>Map创建：</p><pre><code>new Map();与Set不同，其不能通过值列表创建，要使用.set()方法添加键值。</code></pre><p>Map处理：</p><pre><code>.set()方法，有两个参数，第一个参数是键，用来引用第二个参数即值；.delete()方法移除键值对；.clear()清除所有键值对注：.set()方法添加已存在的，不会报错，但会覆盖；.delete()方法删除不存在的，不变；成功为true，失败为false.has()传入键来检查Map中是否存在该键值对.get()方法传入键，检查Map中的值.keys()&amp;.values()将返回新的迭代器对象MapIterator</code></pre><p>Map循环访问：</p><pre><code>1.使用MapIterator和.next()循环访问每个键或值(取决于使用keys或values)2.使用for...of循环访问键值对3.使用Map的.forEach()访问</code></pre><p><strong>(6) WeakMap(弱映射)</strong><br>WeakMap和Map的关键区别：</p><pre><code>1.WeakMap只能包含对象作为键，2.WeakMap无法迭代3.WeakMap没有.clear()方法</code></pre><p>WeakMap创建：new WeakMap()</p><p>垃圾回收：(同WeakSet)</p><p><strong>(7) Promise</strong><br>promise 使你能够展开一些可以异步完成的工作，并回到常规工作</p><p>Promise的创建：</p><pre><code>new Promise()；创建 promise 时，必须向其提供异步运行的代码(即带初始函数);Promise通过向初始函数中传入两个函数来提示请求成功或失败，通常我们将这两个函数称为resolve(成功)和reject(失败)</code></pre><p>Promise立即返回对象</p><pre><code>Promise将立即返回一个对象，该对象具有一个.then()方法，我们可以让该方法通知我们promise中的请求成功与否。.then()方法会接收两个函数：    1.请求成功完成时要运行的函数    2.请求失败时要运行的函数</code></pre><p><strong>(8) Proxy</strong><br>让一个对象代表另一个对象，来处理另一个对象的所有交互。代理可以直接处理请求，接收或发送目标对象数据等。</p><p>Proxy的创建：</p><pre><code>new Proxy()；Proxy构造函数接收两个项目：1.它将要代理的对象2.包含将为被代理对象处理的方法列表的对象(即处理器handler)</code></pre><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">var agent = new Proxy(richard, &#123;&#125;);</span><br><span class="line">agent.status; // returns &apos;looking for work&apos;</span><br></pre></td></tr></table></figure></p><p>handler对象中的Get Trap(捕获器)和Set Trap;trap是一种函数，如果未定义trap,默认行为会被发送给目标对象</p><pre><code>1. Get Trap(捕获器)    get 用来截获对属性的调用,它不会实际地输出属性！    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">const handler = &#123;</span><br><span class="line">      get(target, propName) &#123;</span><br><span class="line">          console.log(target); // the `richard` object, not `handler` and not `agent`</span><br><span class="line">          console.log(propName); // the name of the property the proxy (`agent` in this case) is </span><br><span class="line">                                 //checking</span><br><span class="line">          return target[propName];//可在调用后输出返回的值</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">  const agent = new Proxy(richard, handler);</span><br><span class="line">  agent.status; // logs out the richard object (not the agent object!) and the name of the property </span><br><span class="line">                // being accessed (`status`)</span><br></pre></td></tr></table></figure>2. set trap    set trap 用来截获将更改属性的代码    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">const handler = &#123;</span><br><span class="line">    set(target, propName, value) &#123;</span><br><span class="line">        if (propName === &apos;payRate&apos;) &#123; // if the pay is being set, take 15% as commission</span><br><span class="line">              value = value * 0.85;</span><br><span class="line">            &#125;</span><br><span class="line">          target[propName] = value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  const agent = new Proxy(richard, handler);</span><br><span class="line">  agent.payRate = 1000; // set the actor&apos;s pay to $1,000</span><br><span class="line">  agent.payRate;// $850 the actor&apos;s actual pay</span><br></pre></td></tr></table></figure>3. Proxy中有13种不同的捕获器4. 和ES5种额Getter/Setter相比，    Proxy种的get/set在初始化对象时，不需要针对每个属性使用 getter/setter 初始化对象.</code></pre><p><strong>(9) 生成器(generator)</strong><br>生成器(generator)，可在暂停的函数。</p><p>定义方法：在function后面加上*星号；</p><p>调用：生成器被调用时，不会运行函数中的任何代码，而是创建和返回迭代器。该迭代器可以用来运行实际生成器的内部代码。调用.next()函数。</p><p>在生成器中，出现了关键字yield。yield会导致生成器暂停下来；yield关键字放在要暂停的语句后面，并且迭代器会记住上次暂停的位置；若想用yield向外界生成数据，yield+数据；则每次暂停后会返回该数据</p><p>将数据发送回生成器中，使用.next()方法；例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* displayResponse() &#123;</span><br><span class="line">    const response = yield;//</span><br><span class="line">    console.log(`Your response is &quot;$&#123;response&#125;&quot;!`);</span><br><span class="line"> &#125;</span><br><span class="line">const iterator = displayResponse();</span><br><span class="line">iterator.next(); // starts running the generator function</span><br><span class="line">iterator.next(&apos;Hello Udacity Student&apos;); // send data into the generator</span><br><span class="line">// the line above logs to the console: Your response is &quot;Hello Udacity Student&quot;!</span><br></pre></td></tr></table></figure></p><h2 id="4-专业开发者功能"><a href="#4-专业开发者功能" class="headerlink" title="4.专业开发者功能"></a>4.专业开发者功能</h2><p>主流浏览器的平台功能更新网址：</p><p><a href="https://www.chromestatus.com/features#ES6" target="_blank" rel="noopener">Google Chrome</a></p><p><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/?q=ES6" target="_blank" rel="noopener">Microsoft Edge</a></p><p><a href="https://platform-status.mozilla.org/" target="_blank" rel="noopener">Mozilla Firefox</a></p><p><a href="https://webkit.org/status/" target="_blank" rel="noopener">Safari( Webkit)</a></p><p><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">EMCAScript兼容性表格</a></p><p><strong><a href="https://en.wikipedia.org/wiki/Polyfill" target="_blank" rel="noopener">Polyfill</a></strong><a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills" target="_blank" rel="noopener">polyfill的HTML5样板文件团队</a></p><p>Polyfill是通过复制某些浏览器没有的原生功能，来修复这些缺失的JS文件；<br>Ployfill(或polyfiller)是一段代码(或插件)，可提供本希望浏览器能原生提供的技术<br>    例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!String.prototype.startsWith) &#123;//避免覆盖原生startsWith方法</span><br><span class="line">    String.prototype.startsWith = function (searchString, position) &#123;</span><br><span class="line">        position = position || 0;</span><br><span class="line">        return this.substr(position, searchString.length) === searchString;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel(JS转译器)</a></strong></p><p>Babel可以将ES6转换成ES5，也可以将JSX(JS扩展语言)转化成JS，并将 Flow 转换为JS.</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="ES6" scheme="https://pan-rong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="https://pan-rong.github.io/2018/03/01/CSSnotes/"/>
    <id>https://pan-rong.github.io/2018/03/01/CSSnotes/</id>
    <published>2018-03-01T02:34:36.000Z</published>
    <updated>2018-03-05T09:50:42.300Z</updated>
    
    <content type="html"><![CDATA[<p>CSS简介<br><a id="more"></a><br><strong>1、CSS选择器</strong><br>CSS选择器即通过某种规则来匹配相应的标签，并为其设置CSS样式，常用的有类选择器、标签选择器、ID选择器、后代选择器、群组选择器伪类选择器(before/after)、兄弟选择器(+~)、属性选择器等等。</p><p><strong>2、CSS Reset</strong><br>HTML在不设置任何样式的情况下，也会有一个默认的CSS样式，这是因为浏览器自带的。而不同的浏览器对于这个默认样式的CSS设置也不同，这就会导致代码兼容的问题。为了保证代码的兼容性，通常需要在初始化时，将其统一；用通标符(<em>)可以实现,这就是CSS样式的Reset。例：</em>{margin:0;padding:0}</p><p><strong>3、盒子布局</strong><br>盒子模型是CSS布局的基石。常见的盒子模型有块级盒子(block)和行内盒子(inline-block),与盒子相关的几个属性：margin、border、padding和content等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing属性的设置会影响盒子的width和height的计算.</p><p><strong>4、浮动布局</strong><br>设置元素的float属性值为left或right，就能使该元素脱离普通文档流，向左或向右浮动。一般在宫格布局时会用到，如果子元素全部设置位浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素的末尾加空元素设置clear:both;更高级一点的就给父容器设置before/after来模拟一个空元素，还可以直接设置overflow属性为auto/hidden来清除浮动。初浮动可以实现宫格布局，行内盒子(inline-block)和table也可以实现同样的效果.</p><p><strong>5、定位布局</strong><br>设置元素的position属性值为relative/absolute/fixed,就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，<br>relative是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用；<br>absolute是绝对定位，它以离自己最近的定位父容器作为参照进行偏移；为了对某个元素进行定位，常用的方式就是设置父容器的position:relative,因为相对定位元素在不设置top和left值时，不会对元素位置产生影响；<br>fixed是固定定位，它则以浏览器窗口为参考物，PC网页底部悬停的banner一般都是可以通过fixed定位来实现，但fixed属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动</p><p><strong>6、弹性布局</strong><br>弹性布局即Flex布局，定义了flex容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小；然后当Flex容器被应用一个新尺寸时(width和height),将会自动调整容器中的元素适应新尺寸。Flex容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向(横向和纵向)和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多。注：设为Flex布局后，子元素的float、clear和vertical-align属性将失效.</p><p><strong>7、CSS3动画</strong><br>CSS3中规范引入了两种动画，分别是transition和animation,transition可以让元素的CSS属性值变化在一段时间内平滑的过度，形成动效果，为了使元素的变换更加丰富多彩，CSS3还引入了transfrom属性，它可以通过对元素进行平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew)等操作，来实现2D和3D变化效果。transition还有一个结束事件，transitionEnd,该事件是在CSS完成过渡后触发，如果过渡在完成之前被移除，则不会触发transitionEnd。</p><p><strong>8、Sprite</strong><br>对于大型站点，为了减少http请求次数，一般会将常用的小图标排到一个大图中，页面加载时，只需请求一次网络，然后在css中通过设置background-position来控制显示所有需要的小图标，这就是Sprite图.</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="CSS" scheme="https://pan-rong.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="https://pan-rong.github.io/2018/02/22/HTMLnotes/"/>
    <id>https://pan-rong.github.io/2018/02/22/HTMLnotes/</id>
    <published>2018-02-22T05:34:36.000Z</published>
    <updated>2018-03-05T09:39:25.147Z</updated>
    
    <content type="html"><![CDATA[<p>HTML总体介绍及与HTML5的区别 <a href="https://www.cnblogs.com/zhangyongl/p/6154981.html#undefined" target="_blank" rel="noopener">参考1</a> <a href="http://www.duanliang920.com/learn/web/html5/230.html" target="_blank" rel="noopener">参考2</a><br><a id="more"></a><br><strong>1、BOM</strong><br>    BOM(Browser Object Model)的缩写，及浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局的对象被称为浏览器对象模型，即BOM。BOM的核心对象是window,window对象也是BOM的顶级对象，其中包<br>    含了浏览器6个核心模块(有人说是5个,不包括frames-HTML子框架).</p><pre><code>(1) Document(文档对象)(2) frames-HTML子框架(3) history(4) location(5) navigator(6) screen</code></pre><p><strong>(1) Document(文档对象)</strong><br>    渲染引擎在解析HTML代码时，会为每一个元素生成对应的DOM对象，由于元素之间有层级关系，因此整个HTML代码解析完以后，会生成一个由不同节点组成的树形结构，俗称DOM树，document用于描述DOM树的状态和属性，并提供了很多操作DOM的API.</p><p><strong>(2) frames-HTML子框架</strong><br>    即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文</p><p><strong>(3) history</strong><br>    以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈</p><p><strong>(4) location</strong><br>    提供了当前窗口中加载的文档相关信息以及一些导航功能</p><p><strong>(5) navigator</strong><br>    用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台，用户特性字符串等</p><p><strong>(6) screen</strong><br>    提供了浏览器显示屏幕的相关属性，如：显示屏的宽度和高度，可用宽度和高度</p><p><strong>2、DOM</strong><br>    DOM将HTML和XML文档映射成一个由不同节点组成的树型结构，其核心是document</p><p><strong>3、事件系统</strong><br>事件是用户与页面交互的基础.DOM2.0模型将事件处理流程分为三个阶段：事件捕获阶段、事件处理阶段、事件冒泡阶段<br>    (1)事件捕获：当用户触发点击事件后，顶层对象document就会发出一个事件流，从最外层DOM节点向目标元素节点传递，最终到达目标元素<br>    (2)事件处理：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。<br>    (3)事件冒泡：事件流从目标元素开始，向最外层DOM节点传递，途中如果有节点绑定了事件处理函数，这些函数将会被执行；</p><p>利用事件冒泡原理，可以实现事件委托，所谓委托，就是在父元素上添加监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件，当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素在通过event.targe获取到这个目标元素(之前作品中用this也可以)。这样做的好处是，父元素只需绑定一个事件监听，即可以对所有子元素的事件进行处理，从而减少不必要的事件绑定，对页面性能有一定的提升。</p><p><strong>4、HTML解析过程</strong><br>    (1)浏览器加载html文件<br>    (2)渲染并解析HTML标签，生成DOM节点<br>    (3)渲染并解析CSS样式，生成CSSOM<br>    (4)js脚本处理<br>    (5)将以上打包渲染到浏览器上</p><p><strong>5、重绘和回流</strong><br>    回流：当渲染树中的一部分(或全部)因为元素的规模尺寸、布局、隐藏(主要是display)等改变而需要重新构建；<br>    重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格；而不会影响布局时，就叫重绘；<br>    由此可知，回流必会引起重绘，而重绘不一定会引起回流</p><pre><code>注：transform操作不会引起重绘和回流，是一种高效率的渲染。因为transform属于合成属性，对合成属性进行transition或animation动画时将会创建一个合成层，这使得动画元素在一个独立的层中进行渲染，当元素的内容没有发生改变，就不会重绘和回流。</code></pre><p><strong>6、本地存储</strong><br><strong>(1) cookie</strong><br>    最原始方式，数据以键值对形式保存，可设置过期时间；但不适合大量数据存储；因为每请求一次页面，cookie都会发送给    服务器，因此被限制在4K左右(因浏览器而异)，超出即被忽略，且永不会被设置.</p><p><strong>(2) localStorage和sessionStorage</strong><br>    这是HTML5提供的两种方式，都是以键值对的形式来存储数据；前者是永久存储，后者的存储仅限于浏览器会话(session)。即当浏览器窗口关闭后，sessionStorage中的数据被清除。</p><p>localStorage的存储空间约5M，但在浏览器隐私模式下不可读取，数据超出时会抛异常。</p><p><strong>7、浏览器缓存机制</strong><br>    浏览器缓存机制是通过HTTP协议头里的Cache-Control(或Expires)和Last-Modified(或Etag)等字段来控制文件缓存的机制；Cache-Control用于控制文本在本地缓存有效时长。最常见的，如Cache-Control:max-age=600,表示文件在本地应该缓存，且有效时长为600s.</p><p>Last-Modified是标识文件在服务器上的最新更新时间；若到期，且没有修改，则服务器则返回304告诉浏览器继续用该缓存数据。</p><p><strong>8、History</strong><br>    用户访问网页的历史记录通常会被保存在一个类似于栈的对象中，即history对象，点击返回就出栈，跳下一页就入栈。</p><p><strong>9、Web语义化和SEO</strong><br>    Web语义化是指使用语义恰当的标签，是页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。</p><p>SEO是指了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。</p><p>搜索引擎通过爬虫技术获取的页面就是由一堆html标签组成的代码，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器不行。但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中重要内容，并予以较高的权值。</p><p><strong>10、前端性能优化<a href="http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html" target="_blank" rel="noopener">中文参考</a> <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">英文参考</a></strong><br>提高前端性能可以从以下几个方面入手：<br>(1) 尽量减少HTTP请求数量，如：<br>        图片地图、CSS Sprite、Data URI Scheme(内联资源)、样式表合并、使用Web Font字体图标<br>(2) 缓存，如http头部缓存<br>    <code>&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Tue, 01 Dec 2015 13:30:26 GMT&quot; /&gt;</code><br>    Expires是Web服务器响应消息头字段,在响应http请求时告诉浏览器，若未过期，则直接调缓存.但请求会发生，状态为304，浏览器默认缓存。<br>(3) 使用内容发布网络(CDN使用)//暂时没了解<br>(4)DNS Prefetch //暂时没了解<br>(5)将CSS样式表放在顶部<br>(6)将javascript脚本放在底部<br>(7)使用外部javascript和CSS<br>(8)避免重定向</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="HTML" scheme="https://pan-rong.github.io/tags/HTML/"/>
    
  </entry>
  
</feed>

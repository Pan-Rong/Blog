<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rong</title>
  
  <subtitle>前端学习者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pan-rong.github.io/"/>
  <updated>2018-03-05T09:49:58.577Z</updated>
  <id>https://pan-rong.github.io/</id>
  
  <author>
    <name>Rong Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="https://pan-rong.github.io/2018/03/01/CSSnotes/"/>
    <id>https://pan-rong.github.io/2018/03/01/CSSnotes/</id>
    <published>2018-03-01T02:34:36.000Z</published>
    <updated>2018-03-05T09:49:58.577Z</updated>
    
    <content type="html"><![CDATA[<p>CSS简介<br><a id="more"></a><br><strong>1、CSS选择器</strong><br>CSS选择器即通过某种规则来匹配相应的标签，并为其设置CSS样式，常用的有类选择器、标签选择器、ID选择器、后代选择器、群组选择器伪类选择器(before/after)、兄弟选择器(+~)、属性选择器等等。</p><p><strong>2、CSS Reset</strong><br>HTML在不设置任何样式的情况下，也会有一个默认的CSS样式，这是因为浏览器自带的。而不同的浏览器对于这个默认样式的CSS设置也不同，这就会导致代码兼容的问题。为了保证代码的兼容性，通常需要在初始化时，将其统一；用通标符(<em>)可以实现,这就是CSS样式的Reset。例：</em>{margin:0;padding:0}</p><p><strong>3、盒子布局</strong><br>盒子模型是CSS布局的基石。常见的盒子模型有块级盒子(block)和行内盒子(inline-block),与盒子相关的几个属性：margin、border、padding和content等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing属性的设置会影响盒子的width和height的计算.</p><p><strong>4、浮动布局</strong><br>设置元素的float属性值为left或right，就能使该元素脱离普通文档流，向左或向右浮动。一般在宫格布局时会用到，如果子元素全部设置位浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素的末尾加空元素设置clear:both;更高级一点的就给父容器设置before/after来模拟一个空元素，还可以直接设置overflow属性为auto/hidden来清除浮动。初浮动可以实现宫格布局，行内盒子(inline-block)和table也可以实现同样的效果.</p><p><strong>5、定位布局</strong><br>设置元素的position属性值为relative/absolute/fixed,就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，<br>relative是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用；<br>absolute是绝对定位，它以离自己最近的定位父容器作为参照进行偏移；为了对某个元素进行定位，常用的方式就是设置父容器的position:relative,因为相对定位元素在不设置top和left值时，不会对元素位置产生影响；<br>fixed是固定定位，它则以浏览器窗口为参考物，PC网页底部悬停的banner一般都是可以通过fixed定位来实现，但fixed属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动</p><p><strong>6、弹性布局</strong><br>弹性布局即Flex布局，定义了flex容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小；然后当Flex容器被应用一个新尺寸时(width和height),将会自动调整容器中的元素适应新尺寸。Flex容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向(横向和纵向)和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多。注：设为Flex布局后，子元素的float、clear和vertical-align属性将失效.</p><p><strong>7、CSS3动画</strong><br>CSS3中规范引入了两种动画，分别是transition和animation,transition可以让元素的CSS属性值变化在一段时间内平滑的过度，形成动效果，为了使元素的变换更加丰富多彩，CSS3还引入了transfrom属性，它可以通过对元素进行平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew)等操作，来实现2D和3D变化效果。transition还有一个结束事件，transitionEnd,该事件是在CSS完成过渡后触发，如果过渡在完成之前被移除，则不会触发transitionEnd。</p><p><strong>8、Sprite</strong><br>对于大型站点，为了减少http请求次数，一般会将常用的小图标排到一个大图中，页面加载时，只需请求一次网络，然后在css中通过设置background-position来控制显示所有需要的小图标，这就是Sprite图.</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="CSS" scheme="https://pan-rong.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="https://pan-rong.github.io/2018/02/22/HTMLnotes/"/>
    <id>https://pan-rong.github.io/2018/02/22/HTMLnotes/</id>
    <published>2018-02-22T05:34:36.000Z</published>
    <updated>2018-03-05T09:39:25.147Z</updated>
    
    <content type="html"><![CDATA[<p>HTML总体介绍及与HTML5的区别 <a href="https://www.cnblogs.com/zhangyongl/p/6154981.html#undefined" target="_blank" rel="noopener">参考1</a> <a href="http://www.duanliang920.com/learn/web/html5/230.html" target="_blank" rel="noopener">参考2</a><br><a id="more"></a><br><strong>1、BOM</strong><br>    BOM(Browser Object Model)的缩写，及浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局的对象被称为浏览器对象模型，即BOM。BOM的核心对象是window,window对象也是BOM的顶级对象，其中包<br>    含了浏览器6个核心模块(有人说是5个,不包括frames-HTML子框架).</p><pre><code>(1) Document(文档对象)(2) frames-HTML子框架(3) history(4) location(5) navigator(6) screen</code></pre><p><strong>(1) Document(文档对象)</strong><br>    渲染引擎在解析HTML代码时，会为每一个元素生成对应的DOM对象，由于元素之间有层级关系，因此整个HTML代码解析完以后，会生成一个由不同节点组成的树形结构，俗称DOM树，document用于描述DOM树的状态和属性，并提供了很多操作DOM的API.</p><p><strong>(2) frames-HTML子框架</strong><br>    即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文</p><p><strong>(3) history</strong><br>    以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈</p><p><strong>(4) location</strong><br>    提供了当前窗口中加载的文档相关信息以及一些导航功能</p><p><strong>(5) navigator</strong><br>    用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台，用户特性字符串等</p><p><strong>(6) screen</strong><br>    提供了浏览器显示屏幕的相关属性，如：显示屏的宽度和高度，可用宽度和高度</p><p><strong>2、DOM</strong><br>    DOM将HTML和XML文档映射成一个由不同节点组成的树型结构，其核心是document</p><p><strong>3、事件系统</strong><br>事件是用户与页面交互的基础.DOM2.0模型将事件处理流程分为三个阶段：事件捕获阶段、事件处理阶段、事件冒泡阶段<br>    (1)事件捕获：当用户触发点击事件后，顶层对象document就会发出一个事件流，从最外层DOM节点向目标元素节点传递，最终到达目标元素<br>    (2)事件处理：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。<br>    (3)事件冒泡：事件流从目标元素开始，向最外层DOM节点传递，途中如果有节点绑定了事件处理函数，这些函数将会被执行；</p><p>利用事件冒泡原理，可以实现事件委托，所谓委托，就是在父元素上添加监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件，当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素在通过event.targe获取到这个目标元素(之前作品中用this也可以)。这样做的好处是，父元素只需绑定一个事件监听，即可以对所有子元素的事件进行处理，从而减少不必要的事件绑定，对页面性能有一定的提升。</p><p><strong>4、HTML解析过程</strong><br>    (1)浏览器加载html文件<br>    (2)渲染并解析HTML标签，生成DOM节点<br>    (3)渲染并解析CSS样式，生成CSSOM<br>    (4)js脚本处理<br>    (5)将以上打包渲染到浏览器上</p><p><strong>5、重绘和回流</strong><br>    回流：当渲染树中的一部分(或全部)因为元素的规模尺寸、布局、隐藏(主要是display)等改变而需要重新构建；<br>    重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格；而不会影响布局时，就叫重绘；<br>    由此可知，回流必会引起重绘，而重绘不一定会引起回流</p><pre><code>注：transform操作不会引起重绘和回流，是一种高效率的渲染。因为transform属于合成属性，对合成属性进行transition或animation动画时将会创建一个合成层，这使得动画元素在一个独立的层中进行渲染，当元素的内容没有发生改变，就不会重绘和回流。</code></pre><p><strong>6、本地存储</strong><br><strong>(1) cookie</strong><br>    最原始方式，数据以键值对形式保存，可设置过期时间；但不适合大量数据存储；因为每请求一次页面，cookie都会发送给    服务器，因此被限制在4K左右(因浏览器而异)，超出即被忽略，且永不会被设置.</p><p><strong>(2) localStorage和sessionStorage</strong><br>    这是HTML5提供的两种方式，都是以键值对的形式来存储数据；前者是永久存储，后者的存储仅限于浏览器会话(session)。即当浏览器窗口关闭后，sessionStorage中的数据被清除。</p><p>localStorage的存储空间约5M，但在浏览器隐私模式下不可读取，数据超出时会抛异常。</p><p><strong>7、浏览器缓存机制</strong><br>    浏览器缓存机制是通过HTTP协议头里的Cache-Control(或Expires)和Last-Modified(或Etag)等字段来控制文件缓存的机制；Cache-Control用于控制文本在本地缓存有效时长。最常见的，如Cache-Control:max-age=600,表示文件在本地应该缓存，且有效时长为600s.</p><p>Last-Modified是标识文件在服务器上的最新更新时间；若到期，且没有修改，则服务器则返回304告诉浏览器继续用该缓存数据。</p><p><strong>8、History</strong><br>    用户访问网页的历史记录通常会被保存在一个类似于栈的对象中，即history对象，点击返回就出栈，跳下一页就入栈。</p><p><strong>9、Web语义化和SEO</strong><br>    Web语义化是指使用语义恰当的标签，是页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。</p><p>SEO是指了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。</p><p>搜索引擎通过爬虫技术获取的页面就是由一堆html标签组成的代码，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器不行。但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中重要内容，并予以较高的权值。</p><p><strong>10、前端性能优化<a href="http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html" target="_blank" rel="noopener">中文参考</a> <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">英文参考</a></strong><br>提高前端性能可以从以下几个方面入手：<br>(1) 尽量减少HTTP请求数量，如：<br>        图片地图、CSS Sprite、Data URI Scheme(内联资源)、样式表合并、使用Web Font字体图标<br>(2) 缓存，如http头部缓存<br>    <code>&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Tue, 01 Dec 2015 13:30:26 GMT&quot; /&gt;</code><br>    Expires是Web服务器响应消息头字段,在响应http请求时告诉浏览器，若未过期，则直接调缓存.但请求会发生，状态为304，浏览器默认缓存。<br>(3) 使用内容发布网络(CDN使用)//暂时没了解<br>(4)DNS Prefetch //暂时没了解<br>(5)将CSS样式表放在顶部<br>(6)将javascript脚本放在底部<br>(7)使用外部javascript和CSS<br>(8)避免重定向</p>]]></content>
    
    <summary type="html">
    
      学习笔记
    
    </summary>
    
    
      <category term="HTML" scheme="https://pan-rong.github.io/tags/HTML/"/>
    
  </entry>
  
</feed>

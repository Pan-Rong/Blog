
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6学习笔记 | Rong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习笔记">
<meta name="keywords" content="ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6学习笔记">
<meta property="og:url" content="https://pan-rong.github.io/2018/03/03/ES6notes/index.html">
<meta property="og:site_name" content="Rong">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-05T10:36:24.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6学习笔记">
<meta name="twitter:description" content="学习笔记">
  
    <link rel="alternative" href="/atom.xml" title="Rong" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Rong</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">前端学习者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="pan-rong.github.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-ES6notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/03/ES6notes/" class="article-date">
  <time datetime="2018-03-03T06:30:02.000Z" itemprop="datePublished">2018-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ES6简介<br>ES6是ES5的升级，它们都是JS编程语言现今的最大更新。95年出现了JS语言。<br><a id="more"></a><br>以下从4个方面讲解ES6新增：1.语法 2.函数 3.内置功能 4.开发者工具</p>
<p>1.语法：</p>
<pre><code>新增(1) 变量let和const;(2) 模板字面量;(3) 解构;(4) 对象字面量简写法;(5) 迭代;(6) 展开...运算符;(7) 剩余参数;
</code></pre><p>2.函数：</p>
<pre><code>新增(1) 箭头函数;(2) 函数里新增默认函数参数;(3) JS中的类(和ES5有区别)
</code></pre><p>3.内置功能：</p>
<pre><code>新增(1) Symbol(标识符);(2) Set(集合);(3) WeakSet(弱集合);(4) Map(映射);(5) WeakMap(弱映射);
(6) Promise(异步); (7) Proxy(代理);(8) 生成器(generator);
</code></pre><p>4.开发者工具:</p>
<pre><code>(1) Polyfill;(2) Babel(JS转译器)
</code></pre><h2 id="1-语言上的新增"><a href="#1-语言上的新增" class="headerlink" title="1.语言上的新增"></a>1.语言上的新增</h2><p><strong>(1) 变量let和const</strong><br>两种新的方式来声明变量：let和const；它们的作用域是到块(即用花括号表示)，而不是函数，不会提升；而var会提升到全局作用域或本地作用域即整个函数作用域。</p>
<p>在代码块中使用let和const声明变量，该变量会陷入暂时性死区，直到该变量的声明被处理；这种行为会阻止变量被访问，除非它们被声明了。</p>
<p>let和const的规则</p>
<pre><code>使用let声明的变量可以重新赋值，但是不能在同一作用域内重新声明

使用const声明的变量必须赋初始值，但是不能在同一作用域内重新声明，也无法重新赋值。
</code></pre><p><strong>(2) 模板字面量</strong><br>ES6引入了模板字面量(在ES6开发版本中叫“模板字符串”)，其本质上是包含嵌入式表达式的字符串字面量。</p>
<p>模板字面量是用倒引号(<code></code>)表示，可以包含用${expression}表示的占位符，且将换行符当成字符串的一部分。</p>
<p>模板字面量中的嵌入式表达式不仅仅可以用来引用变量。你可以在嵌入式表达式中进行运算、调用函数和使用循环。</p>
<p><strong>(3) 解构</strong><br>在ES6中，可以使用解构从数组和对象中提取值并赋给独特的变量。</p>
<p>解构：从Perl和Python等语言中获得灵感，使你能够指定要从赋值左侧上的数组或对象中提取的元素。<br>例1 解构数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const point = [10, 25, -34];</span><br><span class="line">const [x, y, z] = point;</span><br><span class="line">console.log(x, y, z);</span><br><span class="line">Prints: 10 25 -34</span><br></pre></td></tr></table></figure></p>
<p>上述中，方括号 [ ] 表示被解构的数组，x、y 和 z 表示要将数组中的值存储在其中的变量。注意，你不需要指定要从中提取值的索引，因为索引可以暗示出来。</p>
<p>例2 解构对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const gemstone = &#123;</span><br><span class="line">type: &apos;quartz&apos;,</span><br><span class="line">color: &apos;rose&apos;,</span><br><span class="line">karat: 21.29</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;type, color, karat&#125; = gemstone;</span><br><span class="line">console.log(type, color, karat);</span><br><span class="line">Prints: quartz rose 21.29</span><br></pre></td></tr></table></figure></p>
<p>上述中，花括号 { } 表示被解构的对象，type、color 和 karat 表示要将对象中的属性存储到其中的变量。因为 gemstone具有 type 属性，值自动存储在 type 变量中。</p>
<p> <strong>(4) 对象字面量简写法</strong><br>在删掉不必要重复代码中，ES6推出了新简写法，例：</p>
<p>对象字面量简写法：<br>用来初始化对象并向对象中添加方法，使用和所分配的变量名称相同的名称初始化对象，可重对象属性中删除该属性。</p>
<p>对象中简写方法名称：<br>对象中添加方法时，可以省掉function关键字</p>
<p> <strong>(5) 迭代</strong><br>(1)、ES6中添加了一个新的可迭代接口，它允许我们自定义对象的迭代方式(即循环遍历方式)，<br>(2)、ES6中新增了一个循环，即for…of..,专门遍历可迭代对象(即实现了这个新迭代接口的对象，如string，array，Map和Set)</p>
<pre><code>for...of循环(优势)
循环访问任何可迭代的数据类型，和for...in相似，但可以忽略索引(代码最简)；
且可随时停止或退出for...of循环；
不用担心向对象中添加新属性，for...of循环只循环访问对象中的值。
</code></pre><p><strong>(6) 展开…运算符</strong><br>ES6中新增了展开运算符(用三个连续的点…表示)，可将字面量对象展开为多个元素<br>例1 展开集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);</span><br><span class="line">console.log(...primes);</span><br><span class="line">Prints: 2 3 5 7 11 13 17 19 23 29</span><br></pre></td></tr></table></figure></p>
<p>例2 结合数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;pears&quot;];</span><br><span class="line">const vegetables = [&quot;corn&quot;, &quot;potatoes&quot;, &quot;carrots&quot;];</span><br><span class="line">//const produce = fruits.concat(vegetables);</span><br><span class="line">const produce = [...fruits,...vegetables];</span><br><span class="line">console.log(produce);</span><br><span class="line">Prints: [&quot;apples&quot;, &quot;bananas&quot;, &quot;pears&quot;, &quot;corn&quot;, &quot;potatoes&quot;, &quot;carrots&quot;]</span><br></pre></td></tr></table></figure></p>
<p><strong>(7) 剩余参数</strong><br>ES6中新增的另一个运算符，剩余参数也用三个连续点…表示，使你能够将不定数量的元素表示为数组。<br>例1、将变量赋数组值时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const order = [20.17, 18.67, 1.50, &quot;cheese&quot;, &quot;eggs&quot;, &quot;milk&quot;, &quot;bread&quot;];</span><br><span class="line">const [total, subtotal, tax, ...items] = order;</span><br><span class="line">console.log(total, subtotal, tax, items);</span><br><span class="line">Prints: 20.17 18.67 1.5 [&quot;cheese&quot;, &quot;eggs&quot;, &quot;milk&quot;, &quot;bread&quot;]</span><br></pre></td></tr></table></figure></p>
<p>例2、可变参数函数(即接受不定数量参数的函数)<br>在此之前可使用参数对象(arguments),现在可以使用剩余参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(...nums) &#123;</span><br><span class="line">  let total = 0;  </span><br><span class="line">  for(const num of nums) &#123;</span><br><span class="line">    total += num;</span><br><span class="line">  &#125;</span><br><span class="line">  return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-函数新增"><a href="#2-函数新增" class="headerlink" title="2.函数新增"></a>2.函数新增</h2><p><strong>(1) 箭头函数(箭头函数表达式)</strong><br>ES6新增函数，箭头函数，例,转换数组中的大小写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const upperizedNames = [&apos;Farrin&apos;, &apos;Kagure&apos;, &apos;Asser&apos;].map(</span><br><span class="line">    name =&gt; name.toUpperCase()</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<pre><code>将“普通”函数转换成箭头函数的步骤：
1.删掉关键字 function
2.删掉圆括号
3.删掉左右花括号
4.删掉关键字 return
5.删掉分号
6.在参数列表和函数主体之间添加一个箭头（=&gt;）
</code></pre><p>箭头函数和普通函数的区别：</p>
<pre><code>普通函数可以是函数声明或函数表达式，但箭头函数始终是表达式；所以仅在表达式有效时才能使用箭头函数，如：
1.存储在变量中
2.当做参数传递给函数
3.存储在对象的属性中

参数列表出现在箭头函数的箭头(=&gt;)前面，当只有一个参数时，可以直接写参数名；若有多个或零个，则需要用圆括号。
当箭头函数的函数主体只有一个表达式时，在函数主体周围没有花括号；自动返回表达式当函数主体需多行代码时，需
将函数主体放在花括号内，需要使用return语句来返回内容.
</code></pre><p>“this”在普通函数和箭头函数中的使用</p>
<pre><code>在普通函数中，this取决于它的函数(或方法)是如何被调用的，例：
1.新的对象(使用new调用)，则构造函数中的this的值是新的对象
2.指定的对象(使用call或apply调用)
  注：call和apply的区别，call方法接受的是若干个参数的列表；而apply方法接受的是一个
      包含多个参数的数组。
3.上下文对象(即点符号左边的对象)
4.全局对象或undefined
  以上三种情况都不存在是，函数中的this的值是全局对象，在严格模式下是undefined

在箭头函数中的this:
箭头函数中，this的值基于函数周围的上下文，即this的值与函数外面的this的值一样
</code></pre><p> <strong>(2) 默认函数参数</strong><br>ES6中新的方式创建默认值，即默认函数参数；<br>要创建默认参数，需要添加等号(=)以及当参数未提供时参数应该设为默认值，其可以为任何JS数据类型</p>
<p>当默认函数参数和解构一起使用时，战斗力提升好几倍~ 例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createGrid([width = 5, height = 5] = []) &#123;</span><br><span class="line">  return `Generating a grid of $&#123;width&#125; by $&#123;height&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">createGrid(); // Generates a 5 x 5 grid</span><br><span class="line">Returns: Generates a 5 x 5 grid</span><br></pre></td></tr></table></figure></p>
<p><strong>(3) JS中的类</strong><br>JS不是基于类的语言，它使用函数来创建对象，并通过原型将它们关联在一起。所谓的JS类本质上还是一样的。</p>
<p>ES5中的类</p>
<pre><code>1.构造函数使用new关键字被调用
2.按照惯例，构造函数名以大写字母开头
3.构造函数控制将被创建的对象的数据的设置
4.“继承”的方法被放在构造函数的原型对象上
</code></pre><p>ES6中类,新类的编写：(注：类里各函数之间不要逗号)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Plane &#123;</span><br><span class="line">  constructor(numEngines) &#123;</span><br><span class="line">    this.numEngines = numEngines;</span><br><span class="line">    this.enginesActive = false;</span><br><span class="line">   &#125;</span><br><span class="line">    startEngines() &#123;</span><br><span class="line">      console.log(&apos;starting engines…&apos;);</span><br><span class="line">      this.enginesActive = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//以下是ES5中的startEngines定义,且ES5中类定义没有构造器函数，像普通函数一样定义</span><br><span class="line">//Plane.prototype.startEngines = function () &#123;</span><br><span class="line">//  console.log(&apos;starting engines...&apos;);</span><br><span class="line">//  this.enginesActive = true;</span><br><span class="line">//&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ES6中的子类<br>在ES6中，使用super和extends关键字扩展类；</p>
<pre><code>关键字extends将自己设为子类，要让子类可以访问到父类，需要使用关键字super。
super既可被用作函数，也可被用作对象，但是super必须在this之前被调用，
</code></pre><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Tree &#123;</span><br><span class="line">    constructor(size = &apos;10&apos;, leaves = &#123;spring: &apos;green&apos;, summer: &apos;green&apos;, fall: &apos;orange&apos;, winter: null&#125;) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.leaves = leaves;</span><br><span class="line">        this.leafColor = null;</span><br><span class="line">    &#125;</span><br><span class="line">    changeSeason(season) &#123;</span><br><span class="line">        this.leafColor = this.leaves[season];</span><br><span class="line">        if (season === &apos;spring&apos;) &#123;</span><br><span class="line">        this.size += 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Maple extends Tree &#123;</span><br><span class="line">    constructor(syrupQty = 15, size, leaves) &#123;</span><br><span class="line">        super(size, leaves);</span><br><span class="line">        this.syrupQty = syrupQty;</span><br><span class="line">    &#125;</span><br><span class="line">    changeSeason(season) &#123;</span><br><span class="line">        super.changeSeason(season);</span><br><span class="line">        if (season === &apos;spring&apos;) &#123;</span><br><span class="line">            this.syrupQty += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gatherSyrup() &#123;</span><br><span class="line">        this.syrupQty -= 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-ES6新增内置功能"><a href="#3-ES6新增内置功能" class="headerlink" title="3.ES6新增内置功能"></a>3.ES6新增内置功能</h2><p><strong>(1) Symbol(标识符)</strong><br>Symbol 只是一个唯一标识符，最常用于唯一标识对象中的属性(如对象中属性的名字相同但value不同时).但是不能用来访问标识符本身。</p>
<p>Symbol的创建：Symbol(),并添加一个可选的字符串作为其描述。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&apos;apple&apos;);</span><br><span class="line">console.log(sym1);//Symbol(apple)</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) 迭代器协议和可迭代协议(不是ES6内置)</strong><br>ES6中新增的两个协议：迭代器协议和可迭代协议</p>
<p>其中，可迭代协议用来定义和自定义对象的迭代行为；工作原理：为了使对象可迭代，它必须实现可迭代接口(即必须包含默认的迭代器方法)。</p>
<p>迭代器协议用来定义对象生成一系列值的标准方式；即定义对象如何迭代的流程。工作原理：<br>    通过执行.next() 方法来完成这一流程。next()方法是无参数函数，返回具有两个属性的<br>    对象：value(下个值数据)和done(为false继续迭代，为true达到末尾);</p>
<p><strong>(3) Set(集合、单值、ES6内置可迭代)</strong><br>Set()数学意义上的集合，即每个数字都是唯一的，只出现一次；不基于索引，不可单独被访问.</p>
<p>Set创建：new  Set();</p>
<p>Set修改：</p>
<pre><code>.add()增加，.delete()删除，.clear()清除
注：若增加时，条目重复，则Set中不增加(返回Set对象)；若删除时，条目没有，则不删除(成功返回true,失败返回false)
</code></pre><p>Set使用：</p>
<pre><code>.size返回条目数；
.has()检查Set中是否存在某个条目，若有返回true，没有返回false
.values()返回Set中的SetIterator对象，即所有值；
.keys()同.values()
</code></pre><p>Set循环访问：</p>
<pre><code>1.使用SetIterator和.next()访问Set中的每一项
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const iterator = months.values();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure>

2.使用for...of循环
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const colors = new Set([&apos;red&apos;, &apos;orange&apos;, &apos;yellow&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;violet&apos;, &apos;brown&apos;, &apos;black&apos;]);</span><br><span class="line">for (const color of colors) &#123;</span><br><span class="line">    console.log(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p><strong>(4) WeakSet(弱集合)</strong><br>WeakSet和Set的区别：</p>
<pre><code>1.WeakSet只能包含对象；
2.WeakSet无法迭代，不能循环访问
3.WeakSet没有.clear()方法
</code></pre><p>WeakSet创建：new WeakSet();</p>
<p>垃圾回收：</p>
<pre><code>JS中创建新值会分配内存，当这些值不需要时，将自动释放内存。该过程就称为垃圾回收

WeakSet 通过专门使用对象作为键值来利用这一点。如果将对象设为 null，则本质上是删除该对象，
当 JS 的垃圾回收器运行时，该对象之前占用的内存将被释放，以便稍后在程序中使用。
</code></pre><p><strong>(5) Map(映射)</strong><br>Map是一个可以存储键值对的对象，键和值都可以是对象、原始值或二者的结合。</p>
<p>Map创建：</p>
<pre><code>new Map();与Set不同，其不能通过值列表创建，要使用.set()方法添加键值。
</code></pre><p>Map处理：</p>
<pre><code>.set()方法，有两个参数，第一个参数是键，用来引用第二个参数即值；
.delete()方法移除键值对；
.clear()清除所有键值对
注：.set()方法添加已存在的，不会报错，但会覆盖；.delete()方法删除不存在的，不变；成功为true，失败为false
.has()传入键来检查Map中是否存在该键值对
.get()方法传入键，检查Map中的值
.keys()&amp;.values()将返回新的迭代器对象MapIterator
</code></pre><p>Map循环访问：</p>
<pre><code>1.使用MapIterator和.next()循环访问每个键或值(取决于使用keys或values)
2.使用for...of循环访问键值对
3.使用Map的.forEach()访问
</code></pre><p><strong>(6) WeakMap(弱映射)</strong><br>WeakMap和Map的关键区别：</p>
<pre><code>1.WeakMap只能包含对象作为键，
2.WeakMap无法迭代
3.WeakMap没有.clear()方法
</code></pre><p>WeakMap创建：new WeakMap()</p>
<p>垃圾回收：(同WeakSet)</p>
<p><strong>(7) Promise</strong><br>promise 使你能够展开一些可以异步完成的工作，并回到常规工作</p>
<p>Promise的创建：</p>
<pre><code>new Promise()；创建 promise 时，必须向其提供异步运行的代码(即带初始函数);
Promise通过向初始函数中传入两个函数来提示请求成功或失败，通常我们将这两个函数称为resolve(成功)和reject(失败)
</code></pre><p>Promise立即返回对象</p>
<pre><code>Promise将立即返回一个对象，该对象具有一个.then()方法，我们可以让该方法通知我们promise中的请求成功与否。
.then()方法会接收两个函数：
    1.请求成功完成时要运行的函数
    2.请求失败时要运行的函数
</code></pre><p><strong>(8) Proxy</strong><br>让一个对象代表另一个对象，来处理另一个对象的所有交互。代理可以直接处理请求，接收或发送目标对象数据等。</p>
<p>Proxy的创建：</p>
<pre><code>new Proxy()；Proxy构造函数接收两个项目：
1.它将要代理的对象
2.包含将为被代理对象处理的方法列表的对象(即处理器handler)
</code></pre><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">var agent = new Proxy(richard, &#123;&#125;);</span><br><span class="line">agent.status; // returns &apos;looking for work&apos;</span><br></pre></td></tr></table></figure></p>
<p>handler对象中的Get Trap(捕获器)和Set Trap;trap是一种函数，如果未定义trap,默认行为会被发送给目标对象</p>
<pre><code>1. Get Trap(捕获器)
    get 用来截获对属性的调用,它不会实际地输出属性！
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">const handler = &#123;</span><br><span class="line">      get(target, propName) &#123;</span><br><span class="line">          console.log(target); // the `richard` object, not `handler` and not `agent`</span><br><span class="line">          console.log(propName); // the name of the property the proxy (`agent` in this case) is </span><br><span class="line">                                 //checking</span><br><span class="line">          return target[propName];//可在调用后输出返回的值</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">  const agent = new Proxy(richard, handler);</span><br><span class="line">  agent.status; // logs out the richard object (not the agent object!) and the name of the property </span><br><span class="line">                // being accessed (`status`)</span><br></pre></td></tr></table></figure>

2. set trap
    set trap 用来截获将更改属性的代码
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const richard = &#123;status: &apos;looking for work&apos;&#125;;</span><br><span class="line">const handler = &#123;</span><br><span class="line">    set(target, propName, value) &#123;</span><br><span class="line">        if (propName === &apos;payRate&apos;) &#123; // if the pay is being set, take 15% as commission</span><br><span class="line">              value = value * 0.85;</span><br><span class="line">            &#125;</span><br><span class="line">          target[propName] = value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  const agent = new Proxy(richard, handler);</span><br><span class="line">  agent.payRate = 1000; // set the actor&apos;s pay to $1,000</span><br><span class="line">  agent.payRate;// $850 the actor&apos;s actual pay</span><br></pre></td></tr></table></figure>

3. Proxy中有13种不同的捕获器

4. 和ES5种额Getter/Setter相比，
    Proxy种的get/set在初始化对象时，不需要针对每个属性使用 getter/setter 初始化对象.
</code></pre><p><strong>(9) 生成器(generator)</strong><br>生成器(generator)，可在暂停的函数。</p>
<p>定义方法：在function后面加上*星号；</p>
<p>调用：生成器被调用时，不会运行函数中的任何代码，而是创建和返回迭代器。该迭代器可以用来运行实际生成器的内部代码。调用.next()函数。</p>
<p>在生成器中，出现了关键字yield。yield会导致生成器暂停下来；yield关键字放在要暂停的语句后面，并且迭代器会记住上次暂停的位置；若想用yield向外界生成数据，yield+数据；则每次暂停后会返回该数据</p>
<p>将数据发送回生成器中，使用.next()方法；例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* displayResponse() &#123;</span><br><span class="line">    const response = yield;//</span><br><span class="line">    console.log(`Your response is &quot;$&#123;response&#125;&quot;!`);</span><br><span class="line"> &#125;</span><br><span class="line">const iterator = displayResponse();</span><br><span class="line">iterator.next(); // starts running the generator function</span><br><span class="line">iterator.next(&apos;Hello Udacity Student&apos;); // send data into the generator</span><br><span class="line">// the line above logs to the console: Your response is &quot;Hello Udacity Student&quot;!</span><br></pre></td></tr></table></figure></p>
<h2 id="4-专业开发者功能"><a href="#4-专业开发者功能" class="headerlink" title="4.专业开发者功能"></a>4.专业开发者功能</h2><p>主流浏览器的平台功能更新网址：</p>
<p><a href="https://www.chromestatus.com/features#ES6" target="_blank" rel="noopener">Google Chrome</a></p>
<p><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/?q=ES6" target="_blank" rel="noopener">Microsoft Edge</a></p>
<p><a href="https://platform-status.mozilla.org/" target="_blank" rel="noopener">Mozilla Firefox</a></p>
<p><a href="https://webkit.org/status/" target="_blank" rel="noopener">Safari( Webkit)</a></p>
<p><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">EMCAScript兼容性表格</a></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Polyfill" target="_blank" rel="noopener">Polyfill</a></strong><a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills" target="_blank" rel="noopener">polyfill的HTML5样板文件团队</a></p>
<p>Polyfill是通过复制某些浏览器没有的原生功能，来修复这些缺失的JS文件；<br>Ployfill(或polyfiller)是一段代码(或插件)，可提供本希望浏览器能原生提供的技术<br>    例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!String.prototype.startsWith) &#123;//避免覆盖原生startsWith方法</span><br><span class="line">    String.prototype.startsWith = function (searchString, position) &#123;</span><br><span class="line">        position = position || 0;</span><br><span class="line">        return this.substr(position, searchString.length) === searchString;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel(JS转译器)</a></strong></p>
<p>Babel可以将ES6转换成ES5，也可以将JSX(JS扩展语言)转化成JS，并将 Flow 转换为JS.</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://pan-rong.github.io/2018/03/03/ES6notes/" data-id="cjeoy9dfk0003zokgrhfeyx1y" class="article-share-link">分享到</a>
      

      
        <a href="https://pan-rong.github.io/2018/03/03/ES6notes/#disqus_thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/05/NPMnotes/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          NPM学习笔记
        
      </div>
    </a>
  
  
    <a href="/2018/03/01/CSSnotes/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">CSS学习笔记</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AJAX/">AJAX</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CORS/">CORS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPM/">NPM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meta/">meta</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AJAX/" style="font-size: 10px;">AJAX</a> <a href="/tags/CORS/" style="font-size: 10px;">CORS</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/NPM/" style="font-size: 10px;">NPM</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/meta/" style="font-size: 15px;">meta</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/11/Flex布局/">Flex布局</a>
          </li>
        
          <li>
            <a href="/2018/03/07/JS获取屏幕尺寸/">JS获取页面、屏幕尺寸</a>
          </li>
        
          <li>
            <a href="/2018/03/06/CSS中float/">CSS布局讲解float、flex使用</a>
          </li>
        
          <li>
            <a href="/2018/03/06/meta标签-IE兼容/">meta标签-IE兼容</a>
          </li>
        
          <li>
            <a href="/2018/03/06/meta中的viewport指令/">meta中的viewport指令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://arvinxiang.com" target="_blank">主题作者</a>
          </li>
        
          <li>
            <a href="http://reqianduan.com" target="_blank">热前端</a>
          </li>
        
          <li>
            <a href="http://yuancheng.work" target="_blank">远程.work</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Rong Pan<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<script>
  var disqus_shortname = 'Pan-Rong';
  
  var disqus_url = 'https://pan-rong.github.io/2018/03/03/ES6notes/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>



<script src="/js/script.js"></script>

</div>
</body>
</html>
